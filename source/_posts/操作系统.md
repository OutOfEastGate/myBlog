---
title: 操作系统
date: 2022-10-03 15:00:36
tags: 操作系统
category: 学习笔记-计网/计组/数据库
cover: https://images.pexels.com/photos/13192126/pexels-photo-13192126.jpeg?auto=compress&cs=tinysrgb&w=600&lazy=load
---

# 第一章 操作系统概述

##  1.什么是操作系统

操作系统，Operating System，简称OS，是覆盖在计算机硬件系统之上的一套软件系统，是第一层软件。

<img src="http://www.wanghongtao.xyz/typora/image-20221003150508191.png" alt="image-20221003150508191" width="40%;" />

## 2.OS的作用

- OS是用户与计算机硬件之间的接口
- OS是计算机系统资源的管理者
  - 一个计算机系统包含的软硬件资源可分为四类：**处理器、存储器、IO设备，及文件**（数据和程序）。 OS就是对这四类资源进行有效管理的。
- OS实现了对计算机资源的抽象

## 3.操作系统的发展历程

**裸机**：从1946年第一台计算机诞生，到20世纪50年代中期。其为电子管计算机（第一代计算机），计算机资 源非常昂贵且操作异常复杂，所以全部是在计算中心进行的集中计算。

裸机的发展过程也经历了两个阶段。

### 3.1 **纯人工操作阶段**

最初使用的是纯人工操作。其缺点很明显：用户独占全机，CPU等待人工操作。

### 3.2 **脱机IO阶段**

为了解决人机矛盾及CPU与IO设备速度不匹配矛盾，在20世纪50年代末出现了脱机IO技术。

脱机IO技术：将IO设备从主机中分离，主机只对磁带进行读写操作。主机不再直接与慢速的IO设备打交道，而是与速度相对较快的磁带机发生关系。

优点：

- 减少了cpu的空闲时间
- 提高了IO速度

### 3.3 单道批处理系统

单道批处理系统出现在20世纪50年代末到60年代中期，其为晶体管计算机（第二代计算机）。

单道批处理系统需要用户事先将一批作业以脱机方式输入到磁带上。该系统中配置了监督程序 **Monitor**。在Monitor控制下，使这批作业逐个连续被处理，充分利用了主机资源。

- 单道：内存中始终只有一道作业
- 批处理：磁带上有多道作业，安装一次磁带，可以处理一批作业

其具体处理过程：

- Monitor将磁带上的第一个作业装入内存，并将运行控制权交给该作业
- 当该作业处理完毕后，再将运行控制权还给Monitor
- Monitor会再将磁带上的第二个作业装入内存，并将运行控制权交给该作业
- 以此类推，走到当前磁带中的所有作业运行完毕。整个过程中是无法与人进行交互的

![image-20221003151807876](http://www.wanghongtao.xyz/typora/image-20221003151807876.png)

> 单道批处理系统存在的问题是：IO执行过程中，主机是闲置状态，**主机利用率低**。因为内存中只有一 道作业。

### 3.4 多道批处理系统

**背景**：1964年IBM生产了第一台小规模集成电路计算机IBM System/360（第三代计算机），并为该计算机开 发了OS/360操作系统，其为第一个多道批处理系统。

**过程**：

多道批处理系统同样要求事先将多道作业存放到外存上并排成一个队列，称为**后备队列**。

然后由作业调度程序Monitor按照一定的算法，从后备队列中选择出若干作业调入内存，使它们共享CPU与系统中 的其它资源。

为充分利用作业调用IO期间的间隙，在Monitor的控制下完成这些作业间CPU使用权的切换。

> 多道批处理系统的优点：处理机利用率高、系统吞吐量大。
>
> 但缺点是：作业平均周转时间长、无交互能力

**需要解决的问题**

- 处理机竞争问题
- 内存分配和保护问题
- IO设备分配问题
- 文件的组织与管理问题
- 作业管理问题
- 用户与系统接口问题

### 3.5 分时系统

#### 发展动力

如果说多道批处理系统的发展动力主要是提高CPU的利用率，提升系统的吞吐量，那么**分时系统**的发展动力就是为了满足人机交互需求。用户对于操作系统的需求主要表现在两方面：

- 人机交互：从用户体验上讲，用户希望在调试、修改一个程序时，能独占全机。可随时修改、调试，无需等待其它程序运行结束。
- 共享主机：从资源利用上讲，在20世纪60年代，昂贵的计算机资源需要通过共享来达到资源充分 利用的目的。

以上两种需求出现了矛盾。而分时系统则解决了这个矛盾。

#### 什么是分时系统

分时系统是指，在一台主机上连接多个配有显示器与键盘的终端并由此构成的系统。该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。

在系统中配置一个多路卡，用于及时接收多终端的用户输入，实现分时多路复用。主机会以很快的速度 周期性的扫描各个终端，在每个终端处停留很短的时间（如30ms），用于接收从终端 发来的数据。

#### 时间片

在多道批处理系统中，对于一个没有IO的长作业，其会长时间独占处理器直至其运行完毕。而这将导致其它作业无法被处理。这是与分时系统的两大特征**（人机交互、共享主机）**相违背的。为了避免这种情况的发生，分时系统中引入了**时间片**概念。

一个时间片就是一段很短的时间（如30ms）。

系统规定每个作业每次只能运行一个时间片，然后就暂停该作业的执行，并调度下一个作业运行。

这样，在较短的时间内就能使所有作业都能执行一个时间片，使每个用户都能及时与自己的作业交互。

### 3.6 实时系统

**实时系统**是指，系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实 时任务协调一致地运行。

> 系统的正确性，不仅由计算逻辑结果确定，还取决于产生结果的时间。也就是说，实时系统将时间作为一个关键参数。

####  实时任务分类

站在不同的角度，实时任务有不同的分类方式：

- （1）周期性实时任务与非周期性实时任务。非周期性实时任务又可以分为开始截止时间任务与完成截 止时间任务。
- （2）硬实时任务HRT （必须满足截止时间要求）与软实时任务SRT（偶尔错过截止时间也不会有太大影响）。

与分时操作系统相比：

- 多路性
- 独立性
- 及时性：以用户能接受的等待时间为准
- 交互性
- 可靠性：多级容错，保障系统和数据的安全

### 3.7 微机操作系统

随着大规模集成电路与计算机体系结构的发展，出现了微机，即PC机，相应的也形成了微机操作系统。

微机操作系统发展历程：

- 单用户单任务系统
- 单用户多任务操作系统
- 多用户多任务操作系统

### 3.8 其他操作系统

网络操作系统

分布式操作系统

## 4.操作系统的基本特性

### 4.1 并发Concurrence

**什么是并发**

并发是指，两个或多个事件在同一时间间隔内发生。

正是该特性使得OS能有效提高系统中资源的利用率，增加系统的吞吐量。

**与并行对比：**

- 并行：两个或多个事件在同一时刻发生。 （多个人干多个事）
- 并发：宏观上的并行，微观上的串行。（一个人干多个事）

#### 并发的实现

之所以可以实现并发，是因为引入了进程这个概念。

所谓进程，是指在系统中能独立运行并作为资源分配的基本单位，有一组指令、数据和堆栈等组成，是 一个能独立运行的活动实体。

### 4.2 共享Sharing

OS系统中的资源共享，也称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。

当系统中资源数量少于多个进程对资源的需求数量时，就会形成对共享资源的争夺。

根据进程对资 源复用方式的不同，目前主要实现资源共享的方式有两种：

**互斥共享**

某些资源只能互斥访问，如打印机、磁带机等。虽然可供多个进程使用，但在一段时间内，只允许一个进程访问该资源。这种互斥访问的资源，称为**临界资源**，或独占资源。

**同时访问**

系统中还有一类资源，允许在一段时间内由多个进程同时访问。不过，对于这个“同时”需要注意，在单处理机环境中，其是宏观上的意义，微观上对这些资源的访问是交替进行，最典型的就是磁盘。



### 4.3 虚拟Virtual

通过某种技术将一个物理实体变为若干个逻辑上的对应物，在OS中这种功能称为虚拟。

而实现虚拟的技术称为虚拟技术。常用的虚拟技术有两种：

**时分复用技术**

复用“某设备为一用户服务的空闲时间”为其它用户服务，以达到充分复用设备的目的。使得看起来好像 是多个用户在同时使用多台相同设备。这种虚拟技术称为时分复用技术。

> 虚拟处理机技术、虚拟打印机技术、虚拟存储器技术等，都属于时分复用技术。
>
> 需要注意速度问题：若某物理设备采用时分复用技术虚拟出了N个虚拟设备，那么每个虚拟设备的平均速度一定是小于等于物理设备速度的 1/N 的。

**空分复用技术**

比如电信业就已经使用频分复用技术来提高信道的复用率，它是指将一个频率范围比较宽的信道划分为多个频率范围较窄的信道（称为频带），其中的任何一个频带都仅供一对用户通话。这种频分复用技术就属于空分复用技术。

> 需要注意空间问题：若某物理设备采用空分复用技术虚拟出了N个虚拟设备，则第个虚拟设备 占用的实际空间一定是小于等于物理设备部空间的 1/N 的

#### Dubbo中的虚拟化

例如，Dubbo在采用一致性Hash算法实现负载均衡时会出现一个问题：提供者Server的增减，仅对某个提供者的负载状态有影响，对其它提供者没有任何帮助。

Dubbo使用“虚拟化思想”对该算进行了优化，默认将一台物理提供者虚拟为了360个(使得hash分散在服务提供者身上更均匀一些)，解决了原来的问题。

### 4.4 异步Asynchronism

异步性也称为不可预知性，不确定性。而同步就是确定的，可预知的，可再现的。

对于内存中的每个进程，有的侧重于计算而IO少，有的则计算少而IO多。它们何时能够获取到处理器运行、何时由于提出临界资源请求而暂停，每道作业总共需要多少时间才能完成，都是不可预知的，不确定的。可能先进入内存的进程后完成，而后进入内存的作业先完成。这种进程以不可预知的速度向前推进的特性，称为异步性。

只要OS中配置有完善的**进程同步机制**，且运行环境相同，则作业即使经过多次运行，也可以获得完全相同的结果。即OS的异步性是不会影响到作业的运行结果的。

## 5. 操作系统的运行机制

**用户空间与内核空间**

CPU运行模式有两种：用户程序/用户态->内核程序/核心态

通过中断可完成两种状态的切换

![image-20221012143721092](http://www.wanghongtao.xyz/typora/image-20221012143721092.png)

**时钟管理**

- 计时
- 时钟中断

**中断机制**

**原语**

原子操作

原理：关操作和开操作

**系统数据结构**

- 进程管理：作业控制块、进程控制块

- 存储器管理：存储器分配与回收

- 设备管理：缓冲区、设备控制块

**系统调用**

- 由操作系统实现，给应用程序调用
- 是一套接口的集合
- 应用程序访问内核服务的方式

## 6. 操作系统的结构

### 6.1 第一代：无结构操作系统

os是为数众多的一组过程的集合，每个过程可以任意地相互调用其他过程，

使得操作系统内部复杂又混乱

### 6.2 第二代：模块化结构OS

- 基于“分解”和“模块化”原则
- 按照功能划分模块/子模块，规定模块间的接口
- 模块独立性标准：高内聚、低耦合

### 6.3 第三代：分层式结构OS

有序分层法，自顶向上：每一步建立在可靠性的基础之上

优缺点：

- 容易保证系统的正确性
- 容易扩充和维护
- 自上而下的层次通信，导致系统效率降低

### 6.4 第四代：微内核OS结构

基本概念：足够小的内核，只实现OS核心功能，如与硬件处理紧密相关的部分，硬件处理、客户与服务器通信（客户/服务器模式）和其他基本功能

- 采用“机制与策略分离”原理
- 采用面向对象技术

微内核的OS的优点

- 提高OS的可扩展性、可靠性、可移植性
- 支持分布式系统
- 融入了面向对象技术

微内核的OS的缺点

- 相较早期OS,降低了一定的效率

# 第二章 进程的描述与控制

## 1.什么是进程

进程，一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度的一个独立单位。

- 进程是程序的一次执行（实例）
- 进程是一个车光绪及其数据在处理机上顺序执行时所发生的活动
- 进程是程序在一个数据集合上运行的过程
- 进程时系统进行资源分配和调度的一个独立单位

### 1.1 进程的特征

- 动态性：由创建而生，由撤消而亡
- 并发性：多个进程同时运行
- 独立性：独立资源分配
- 异步性：相互独立，互不干扰

### 1.2 进程与线程

- Thread,进程的轻型实体，也叫"轻量级进程”，是系列活动
  按事先设定好的顺序依次执行的过程，是一系列指令的集合
- 是一条执行路径，不能单独存在，必须包含在进程中
- 线程是OS中运算调度的最小单位

为什么引入线程？

提高OS的并发性
### 1.3 线程的属性

- 轻型实体
- 独立调度和分派的基本单位
- 可并发执行
- 共享进程资源

### 1.4 线程的实现方式

- 用户级线程（User Level Thread）
- 内核级线程（Kernel Level Thread）

![image-20221012154559684](http://www.wanghongtao.xyz/typora/image-20221012154559684.png)

## 2. 进程是怎么运行的？

### 2.1 进程的状态

进程的三种基本状态

- 就绪（Ready）
- 执行（Running）
- 阻塞（Blocked）

<img src="http://www.wanghongtao.xyz/typora/image-20221012155807929.png" alt="image-20221012155807929" width="50%;" />

- 创建（New）
- 终止（Terminated）

创建后并不是就绪状态，而是New状态

当执行完毕后进入终止状态

### 2.2 进程控制

即OS对进程实现有效的管理，包括创建新进程、撤销已有进程、挂起、阻塞和唤醒、进程切换等多种操作。OS通过**原语(Primitive)**操作实现进程控制。

**原语的概念**：
由若干条指令组成，完成特定的功能，是一种**原子操作(Atomic Operation)**
**原语的特点**：
原子操作，要么全做，要么全不做，执行过程不会被中断
在管态/系统态/内核态下执行，常驻内存
是内核三大支撑功能（中断处理/时钟管理/原语操作）之一

- 创建原语：create
- 阻塞原语：block
- 唤醒原语：wakeup
- 撤销原语：destroy

<img src="http://www.wanghongtao.xyz/typora/image-20221012161223723.png" alt="image-20221012161223723" width="50%;" />

- 挂起原语：suspend
  - 静止就绪：放外存，不调度
  - 静止阻塞：等待事件

- 激活原语：active
  - 活动就绪：等待调度
  - 活动阻塞：等待唤醒

<img src="http://www.wanghongtao.xyz/typora/image-20221012162017357.png" alt="image-20221012162017357" width="60%;" />



### 2.3 处理机调度：调度的层次

**高级调度/作业调度**

- 把后备作业调入内存
- 只调入一次，调出一次

**中度调度/内存调度**

- 将进程调至外存，条件合适再调入内存
- 再内、外存对换区进行进程对换

**低级调度/进程调度**

- 从就绪队列选取进程分配给处理机
- 最基本的调度，频率非常高

<img src="http://www.wanghongtao.xyz/typora/image-20221012163618755.png" alt="image-20221012163618755" width="50%;" />


**剥夺式/抢占式调度**

- 立即暂停当前进程
- 分配处理机给另一个进程
- 原则：优先权/短进程优先/时间片原则

**非剥夺/非抢占式调度**

- 若有进程请求执行
- 等待直到当前进程完成或阻塞
- 缺点：适用于批处理系统，不适用分时/实时系统

**处理机调度：调度时机**

- 进程运行完毕
- 进程时间片用完
- 进程要求/O操作
- 执行某种原语操作
- 高优先级进程申请运行（剥夺式调度）

**处理机调度：调度过程**

- 保存镜像：记录进程现场信息
- 调度算法：确定分配处理机的原则
- 进程切换：分配处理机给其它进程
- 处理机回收：从进程收回处理机

**进程调度：调度算法指标**

- CPU利用率
- 系统吞吐量
- 周转时间
- 等待时间
- 响应时间

### 2.4 处理机调度：调度算法

作业调度

- 先来先服务（FCFS，First Come First Served）
- 短作业优先（SJF，Shortest Job First）
- 高响应比优先调度（HRRN，Highest Response Ratio Next）
- 优先级调度（PSA，Priority-Scheduling Algorithm）

进程调度

- 先来先服务（FCFS，First Come First Served）
- 短作业优先（SJF，Shortest Job First）
- 高响应比优先调度（HRRN，Highest Response Ratio Next）
- 优先级调度（PSA，Priority-Scheduling Algorithm
- 时间片轮转调度（RR，Round-Robin）
- 多级反馈队列调度（MFQ，Multilevel Feedback Queue）

#### 进程调度：先来先服务（FCFS，First Come First Served）

算法内容：调度作业/就绪队列中最先入队者，等待操作完成或阻塞
算法原则：按作业/进程到达顺序服务（执行）
调度方式：非抢占式调度
适用场景：作业/进程调度
优缺点：

- 有利于CPU繁忙型作业，充分利用CPU资源
- 不利于I/O繁忙型作业，操作耗时，其它饥饿

#### 进程调度：短作业优先（SJF，Shortest Job First ）

算法内容：所需服务时间最短的作业/进程优先服务（执行）
算法原则：追求最少的平均（带权）周转时间
调度方式：SJF/SPF非抢占式
适用场景：作业/进程调度
优缺点：

- 平均等待/周转时间最少
- 长作业周转时间会增加或饥饿
- 估计时间不准确，不能保证紧迫任务及时处理

#### 进程调度：高响应比优先调度（HRRN，Highest Response Ratio Next）

算法内容：结合FCFS和SJF，综合考虑等待时间和服务时间计算响应比，高的优先调度
算法原则：综合考虑作业/进程的等待时间和服务时间
调度方式：非抢占式
适用场景：作业/进程调度
响应比计算：

- 响应比=(等待时间+服务时间)/服务时间, ≥1
- 只有当前进程放弃执行权（完成/阻塞）时，重新计算所有进程响应比
- 长作业等待越久响应比越高，更容易获得处理机

![image-20221013085332071](http://www.wanghongtao.xyz/typora/image-20221013085332071.png)

#### 进程调度：优先级调度（PSA，Priority-Scheduling Algorithm）

算法内容：又叫优先权调度，按作业/进程的优先级（紧迫程度）进行调度
算法原则：优先级最高（最紧迫）的作业/进程先调度
调度方式：抢占/非抢占式（并不能获得及时执行）
适用场景：作业/进程调度
优先级设置原则：

- 静态/动态优先级
- 系统>用户；交互型>非交互型；I/O型>计算型
- 低优先级进程可能会产生“饥饿”

> 剥夺式：高优先级立即执行
>
> 非剥夺式：高优先级等待当前进程让出处理机后执行

#### 进程调度：时间片轮转调度（RR，Round-Robin）

算法内容：按进程到达就绪队列的顺序，轮流分配一个时间片去执行，时间用完则剥夺
算法原则：公平、轮流为每个进程服务，进程在一定时间内都能得到响应
调度方式：抢占式，由时钟中断确定时间到
适用场景：进程调度
优缺点：

- 公平，响应快，适用于分时系统
- 时间片决定因素：系统响应时间、就绪队列进程数量、系统处理能力
- 时间片太大，相当于FCFS；太小，处理机切换频繁，开销增大

#### 进程调度：多级反馈队列调度（MFQ，Multileveled Feedback Queue）

算法内容：
设置多个按优先级排序的就绪队列
优先级从高到底，时间片从小到大
新进程采用队列降级法
进入第一级队列，按FCFS分时间片
没有执行完，移到第二级，第三级。。。
前面队列不为空，不执行后续队列进程

算法原则：集前几种算法优点，相当于PSA+RR
调度方式：抢占式
适用场景：进程调度
优缺点：

- 对各类型相对公平；快速响应；
- 终端型作业用户：短作业优先
- 批处理作业用户：周转时间短
- 长批处理作业用户：在前几个队列部分执行

![image-20221013091326057](http://www.wanghongtao.xyz/typora/image-20221013091326057.png)

## 3.进程之间是怎么协作的？

•**进程间的协作**

**进程通信**

**进程同步**

### 3.1 进程通信

概念：进程通信即进程间的信息交换
进程是资源分配的基本单位，各进程内存空间彼此独立
一个进程不能随意访问其它进程的地址空间
特点：

- 共享存储（Shared-Memory）
- 消息传递（Message-Passing）
- 管道通信（Pipe）

#### 进程通信：共享存储（Shared-Memory）

基于共享数据结构的通信方式

- 多个进程共用某个数据结构（OS提供并控制）
- 由用户（程序员）负责同步处理
- 低级通信：可以传递少量数据，效率低

基于共享存储区的通信方式

- 多个进程共用内存中的一块存储区域
- 由进程控制数据的形式和方式方式
- 高级通信：可以传递大量数据，效率高

<img src="http://www.wanghongtao.xyz/typora/image-20221013101513436.png" alt="image-20221013101147336" width="30%;" />

#### 进程通信：消息传递（Message-Passing）

- 直接通信：点到点发送
  发送和接收时指明双方进程的ID
  每个进程维护一个消息缓冲队列
- 间接通信：广播信箱
  以信箱为媒介，作为中间实体
  发进程将消息发送到信箱，收进程从信箱读取
  可以广播，容易建立双向通信链

<img src="http://www.wanghongtao.xyz/typora/image-20221013102620178.png" alt="image-20221013102620178" width="33%;" />

<img src="http://www.wanghongtao.xyz/typora/image-20221013102649974.png" alt="image-20221013102649974" width="33%;" />

#### 进程通信：管道通信（Pipe）

管道

- 用于连接读/写进程的共享文件，pipe文件
- 本质是内存中固定大小的缓冲区

半双工通信

- 同一时段只能单向通信，双工通信需要两个管道
- 以先进先出（FIFO）方式组织数据传输
- 通过系统调用read()/write()函数进行读写操作

### 3.2 进程同步

协调进程间的相互制约关系，使它们按照预期的方式执行的过程
**前提**

- 进程是并发执行的，进程间存在着相互制约关系
- 并发的进程对系统共享资源进行竞争
- 进程通信，过程中相互发送的信号称为消息或事件

**两种相互制约形式**

- 间接相互制约关系（互斥）：进程排他性地访问共享资源
- 直接相互制约关系（同步）：进程间的合作，比如管道通信

#### 3.2.1 进程同步：互斥的访问临界资源

访问过程

1. 进入区：尝试进入临界区，成功则**加锁（lock）**
2. 临界区：访问共享资源
3. 退出区：**解锁（unlock）**，唤醒其它阻塞进程
4. 剩余区：其它代码

访问原则

- 空闲让进：临界区空闲，允许一个进程进入
- 忙则等待：临界区已有进程，其它进程等待（阻塞状态）
- 有限等待：处于等待的进程，等待时间有限
- 让权等待：等待时应让出CPU执行权，防止“忙等待”


#### 3.2.2 **软件实现方法**

- 单标志法：违背“空闲让进”
- 双标志法先检查
- 双标志法后检查
- 皮特森算法（Peterson's Algorithm）

##### 单标志法

**违背“空闲让进”**

只能p0进程和p1进程交替访问临界资源

<img src="http://www.wanghongtao.xyz/typora/image-20221013145907571.png" alt="image-20221013145907571" width="50%;" />

##### 双标志法先检查

**违背“忙则等待”**

<img src="http://www.wanghongtao.xyz/typora/image-20221013150159392.png" alt="image-20221013150159392" width="50%;" />

##### 双标志法后检查

违背“空闲让进”、“有限等待”

<img src="http://www.wanghongtao.xyz/typora/image-20221013150522268.png" alt="image-20221013150522268" width="50%;" />

##### 皮特森算法（Peterson's Algorithm）

违背“让权等待”，会发生“忙等”

<img src="http://www.wanghongtao.xyz/typora/image-20221013150637507.png" alt="image-20221013150637507" width="50%;" />

#### 3.2.3 **硬件实现方法**

- 中断屏蔽法：关中断/开中断
- Test-And-Set（TS指令/TSL指令）
- Swap指令

##### 中断屏蔽法：关中断/开中断

- 禁止一切中断，CPU执行完临界区之前不会切换
- 关中断可能会被滥用
- 关中断时间长影响效率
- 不适用于多处理机，无法防止其它处理机调度其它进程访问临界区
- 只适用于内核进程（该指令运行在内核态）

<img src="http://www.wanghongtao.xyz/typora/image-20221013154334720.png" alt="image-20221013154334720" width="50%;" />

##### Test-And-Set（TS指令/TSL指令）

- 读出标志并设置为true，返回旧值，**原子操作**
- 也被称作TSL指令（ Test-And-Set-Lock ）
- 违背“让权等待”，会发生忙等

<img src="http://www.wanghongtao.xyz/typora/image-20221013154706237.png" alt="image-20221013154706237" width="50%;" />

##### Swap指令（ EXCHANGE，XCHG指令）

- 交换两个变量的值，原子操作
- 违背“让权等待”

<img src="http://www.wanghongtao.xyz/typora/image-20221013154935500.png" alt="image-20221013154935500" width="50%;" />

##### 信号量（Semaphore）机制

PV操作：

- P操作：wait原语，进程等待
- V操作：signal原语，唤醒等待进程

整型信号量：违背“让权等待”，会发生忙等
记录型信号量：进程进入阻塞状态，不会忙等

<img src="http://www.wanghongtao.xyz/typora/image-20221013155206555.png" alt="image-20221013155206555" width="40%;" />

### 3.2.4 进程同步：管程（Monitor，监视器）

管程：“管理进程”，即用于实现进程同步的工具。是由代表共享资源的数据结构和一组过程（进行PV操作的函数）组成的管理程序（封装）。

管程的组成

- 管程名称
- 局部于管程内部的共享数据结构
- 对该数据结构操作的一组过程（函数）
- 管程内共享数据的初始化语句

管程的基本特性

- 是一个模块化的基本程序单位，可以单独编译
- 是一种抽象数据类型，包含数据和操作
- 信息掩蔽，共享数据只能被管程内的过程访问

条件变量/条件对象

- 进入管程的进程可能由于条件不满足而阻塞
- 此时进程应释放管程以便其它进程调用管程
- 进程被阻塞的条件（原因）有多个，移入不同的条件队列
- 进程被移入条件队列后，应释放管程

<img src="http://www.wanghongtao.xyz/typora/image-20221013162125494.png" alt="image-20221013162125494" width="50%;" />

## 4. 如何处理死锁问题？

### 4.1 死锁的概念

**死锁定义**：多个进程由于竞争资源而造成的阻塞现象，若无外力作用，这些进程将无法继续推进。
相似概念->饥饿：等待时间过长以至于给进程推进和响应带来明显影响，“饿而不死”

**死锁产生的原因**

- 系统资源的竞争
- 进程推进顺序非法

**死锁产生的必要条件**

- 互斥条件：共享资源的排他性访问
- 不剥夺条件：访问时该共享资源不会被剥夺
- 请求并保持条件：保持当前资源时请求另一个资源
- 循环等待条件：存在共享资源的循环等待链

### 4.2 死锁的处理策略

**死锁预防**

- 破坏互斥条件
- 破坏不剥夺条件
- 破坏请求并保持条件
- 破坏循环等待条件

**死锁避免**

- 系统安全状态
- 安全性算法
- 银行家算法

**死锁的检测与解除**

- 资源分配图
- 死锁定理
- 死锁解除

#### 4.2.1 死锁预防：破坏互斥条件

- 将只能互斥访问的资源改为同时共享访问
- 将独占锁改为共享锁
- 不是所有资源都能改成可共享的

<img src="http://www.wanghongtao.xyz/typora/image-20221013171713996.png" alt="image-20221013171713996" width="50%;" />



#### 4.2.2 死锁预防：破坏不剥夺/不可抢占条件

- 请求新资源无法满足时必须释放已有资源
- 由OS协助强制剥夺某进程持有的资源
- 实现复杂，代价高
- 此操作过多导致原进程任务无法推进

#### 4.2.3 死锁预防：破坏请求并保持条件

进程开始运行时一次性申请所需资源

- 资源浪费
- 进程饥饿

阶段性请求和释放资源

<img src="http://www.wanghongtao.xyz/typora/image-20221013172005171.png" alt="image-20221013172005171" width="40%;" />

#### 4.2.4 死锁预防：破坏循环等待条件

对所有资源现行排序，按序号请求资源

- 请求时先低再高
- 释放时先高再低

对资源的编号应相对稳定，限制了新设备增加

进程使用资源的顺序可能与系统编号顺序不同

限制了用户编程

#### 4.2.5 死锁避免：安全性算法

系统安全状态

- 安全状态一定不会出现死锁
- 不安全状态可能出现死锁

银行家算法

- 系统预判进程请求是否导致不安全状态
- 是则拒绝请求，否则答应请求

#### 4.2.6 死锁的检测与解除

**死锁检测**

- 需要一种数据结构，保存有关资源的请求和分配信息
- 提供一种算法，利用这些信息检测是否形成了死锁

资源分配图（G=(N, E)）：

- 两种资源
- 两种节点

死锁定理（死锁状态的充分条件）：

- 当且仅当此状态下资源分配图是不可完全简化的
- 简化过程类似于“拓扑排序”算法（注意数据结构考察）
  - 找到既不孤立又不阻塞的节点
  - 去掉其入边和出边（它第一个执行，因为它可以正常执行）
  - 如果按这个顺序，最终所有节点都是孤立节点，那么说明可以正常执行

<img src="http://www.wanghongtao.xyz/typora/image-20221013172737214.png" alt="image-20221013172737214" width="33%;" />

**死锁解除**

- 资源剥夺
  - 挂起死锁进程
  - 剥夺其资源
  - 将资源分配给其它（死锁）进程
- 撤销进程
- 进程回退
  - 回退到足以避免死锁的地步
  - 需要记录进程历史信息，设置还原点

![image-20221013173006523](http://www.wanghongtao.xyz/typora/image-20221013173006523.png)

#  第三章 内存管理

## 1. 什么是内存管理















