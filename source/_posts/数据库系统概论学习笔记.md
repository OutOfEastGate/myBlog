---
title: 数据库系统概论学习笔记(一)
date: 2022-05-30 19:46:53
tags: 数据库
category: 学习笔记-计网/计组/数据库
swiper_index: 1
description: 数据库考前复习
cover: https://images.pexels.com/photos/12226848/pexels-photo-12226848.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260
---
{% timeline 数据库系统概论复习,blue %}

<!-- timeline  -->

创建，教学视频：bilibili [张旭](https://www.bilibili.com/video/BV1jf4y147jz?p=9&spm_id_from=333.1007.top_right_bar_window_history.content.click)

<!-- endtimeline -->

<!-- timeline  -->

更新

<!-- endtimeline -->


{% endtimeline %}



## 一、绪论

### 概念模型

- 实体：客观存在并可相互区别的事物，人
- 属性：实体所具有的性质和特性
- 码：唯一标识实体的属性。学号id等
- 实体型：用实体名和其属性集合来刻画同类实体。如分数为100的学生
- 实体集： 同一类型的集合

>实体之间有一对一、一对多和多对多等多种联系
>
>概念模型的一种表示方法：实体-联系方法，用E-R图来描述现实世界的概念模型，也叫E-R模型

### 逻辑模型

- 层次模型
    - 有且只有一个节点没有双亲节点，这个节点成为根节点
    - 根节点以外其他节点有且只有一个双亲节点
- 网状模型
    - 允许一个以上的节点无双亲
    - 一个节点可以有多个双亲
- 关系模型
    - 一张表包含字段属性等

>关系：一个关系对应通常说的一张表
>
>元组：表的一行
>
>属性：表的一列
>
>码：也称码键，表中某个属性组
>
>域：是一组具有相同数据类型的值得集合
>
>分量：元组的一个属性

### 三层模式结构 外模式+模式+内模式

- 外模式：用户能够看到的局部数据逻辑结构
- 模式：也称为逻辑模式，数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图
- 内模式：也称存储模式，一个数据库只能够有一个内模式，它是数据物理结构和存储方式的描述，数据在内部的组织方式

[![XlcEz8.png](https://s1.ax1x.com/2022/05/30/XlcEz8.png)](https://imgtu.com/i/XlcEz8)

## 二、关系数据库

### 关系数据结构

•**域**

•**笛卡尔积**

•**关系**

​	– **关系，属性，元组**

​	– **候选码，主码，主属性**

​	– **基本关系的性质**

### 关系的操作

{% tabs test4 %}

<!-- tab 查询 -->
**选择、投影、连接、除、并、交、差**
<!-- endtab -->

<!-- tab 数据更新 -->
**插入、删除、修改**
<!-- endtab -->

<!-- tab 基本运算 -->
**并、差、笛卡尔积、投影、选择**
<!-- endtab -->

{% endtabs %}

#### **关系代数运算符**

<img src="https://s1.ax1x.com/2022/05/30/XlgXuD.md.jpg" width="50%" />

交并差这里不再赘述。

#### 笛卡尔积

![](https://s1.ax1x.com/2022/05/30/Xl2bIs.md.jpg)

笛卡尔积即是两个表的元组之间排列组合

#### 选择

比如 在student表中选择sdept=‘2s’的全部信息
$$
\sigma_{sdept}='2s'(student)
$$

#### 投影

查询指定属性，如查询sname，sex在student表中
$$
\pi_{sname,sex}(student)
$$
比如在表SC中查询学号(sno)为95001的学生选修的课程号(cno)
$$
\pi_{cno}(\sigma_{sno}='95001'(SC))
$$

#### 连接

##### 自然连接

自然连接：把共同属性进行等值连接

悬浮元组：在连接时，R中某些元组可能不存在与公共属性相等的值，从而造成关系R中的这些元组被舍弃，这些被舍弃的元组称为悬浮元组。如下面例子当中的第二三五行就是悬浮元组

例如表R连接表S表示为
$$
R\bowtie S
$$
![](https://s1.ax1x.com/2022/05/30/XlfrrT.md.jpg)

##### 外连接

{% tabs test4 %}

<!-- tab 外连接 -->
外连接：把悬浮元组也包括在结果当中，其他属性为null。
<!-- endtab -->

<!-- tab 左外连接 -->
左外连接：只保存左边关系的悬浮元组
<!-- endtab -->

<!-- tab 右外连接 -->
右外连接：只保存右边关系的悬浮元组
<!-- endtab -->

{% endtabs %}

#### 除

除：保留R中满足S的(R和S的共同属性)，而且R中列要去掉S的列

<img src="https://s1.ax1x.com/2022/05/30/X1mx56.md.jpg" width="50%" />

<img src="https://s1.ax1x.com/2022/05/30/X1upoq.md.jpg" width="50%" />

### 关系的完整性

{% tabs test4 %}
<!-- tab 实体完整性 -->
主码唯一且非空
<!-- endtab -->

<!-- tab 参照完整性 -->
外码要么为空，要么对应另一表的主码
<!-- endtab -->

<!-- tab 用户定义完整性 -->

实体的属性要完整，比如学号多少，姓名，班级，专业之类

<!-- endtab -->
{% endtabs %}

----

## 三、SQL语言

#### 查询

![](https://s1.ax1x.com/2022/05/30/X1KZ38.png)

| 查 询  条 件         | 谓  词                                              |
| -------------------- | --------------------------------------------------- |
| 比  较               | =，>，<，>=，<=，!=，<>，!>，!<；NOT+上述比较运算符 |
| 确定范围             | BETWEEN  AND，NOT  BETWEEN AND                      |
| 确定集合             | IN，NOT  IN                                         |
| 字符匹配             | LIKE，NOT  LIKE                                     |
| 空  值               | IS  NULL，IS  NOT NULL                              |
| 多重条件（逻辑运算） | AND，OR，NOT                                        |

**案例**

<img src="https://s1.ax1x.com/2022/05/30/X13D10.jpg" width="50%" />

##### 查询&起别名

- 查询所有 

```sql
select * from edu_student;
```



- 查询id(别名标志)，title(别名课程名称)，从edu_course表（别名ec）中

```sql
select id 标志,title 课程名称 from edu_course ec;
```



结果去重 distinct

- 去掉重复的课程名称

```sql
select distinct title 课程名称 from edu_course;
```

带有函数的查询：

{%folding green ,带有函数的查询%}

**空值替换和字符串连接**

```sql
SELECT 
	CONCAT(first_name,' ',last_name) as Name,
	IFNULL(phone,"Unknown") as Phone
FROM
customers
```

输出结果：

Babara MacCaffrey	781-932-9754
Ines Brushfield	804-427-9456
Freddi Boagey	719-724-7869
Ambur Roseburgh	407-231-8017
Clemmie Betchley	Unknown
Elka Twiddell	312-480-8498
Ilene Dowson	615-641-4759
Thacher Naseby	941-527-3977
Romola Rumgay	559-181-3744
Levy Mynett	404-246-3370

{%endfolding%}

##### 条件查询

- where 查询价格大于等于88的课程名称

```sql
select title 课程名称 from edu_course where price>=88
```

- in 查询结果是否在集合中

```sql
select 3 in (1,2);
```

- like 模糊匹配

```sql
select * from edu_course where title like '_速成';
```

> '-'代表一个不确定字符
>
> '%'代表多个不确定字符

{% folding green, REGEXP运算符(正则表达式) %}
REGEXP(regular expression 正则表达式)可以执行比like更复杂的语句

```sql
SELECT * FROM customers
WHERE last_name LIKE '%field%'
```

可以写成

```sql
SELECT * FROM customers
WHERE last_name REGEXP 'field'
```

如果将'field'改为'^field':表示以field开头

如果将'field'改为'field$':表示以field结尾

```sql
SELECT * FROM customers
WHERE last_name REGEXP 'field|mac|rose'
```

表示姓名中含有field或mac或rose

可以将'field|mac|rose'可以换成'^field|mac|rose'，表示将“含有field”换成了“以field开头”，同样也可以$实现结尾的方式

```sql
SELECT * FROM customers
WHERE last_name REGEXP '[gim]e'
```

表示含有'ge'或'ie'或'me'的人，同样也可将中括号放在e的后面

也可以将'[gim]e'换成'[a-h]e'表示从a到h分别和e匹配，即'ae,be,ce....'

{% endfolding %}

isnull 和is not null不再赘述

{%folding 查询结果排序%}

按照firstname降序排列：

```sql
SELECT * FROM customers
ORDER BY first_name DESC
```

按照state降序，firstname升序排列

```sql
SELECT * FROM customers
ORDER BY state DESC ,first_name ASC
```

也可以在sql语句中加入表达式：

```sql
SELECT *,quantity * unit_price as total_price
FROM order_items
WHERE order_id=2
ORDER BY total_price DESC
```

{%endfolding%}

{%folding 带有计数、求值的查询%}

![image-20220530173820872](https://s1.ax1x.com/2022/05/30/X1GvOf.png)

- 查询学生总人数

```sql
select count(*) from student;
```

- 查询1号课程的学生平均成绩

```sql
select avg(grade) from sc where cno ='1';
```

这些带有count的查询语句一般都要进行分组，否则将毫无意义，这时就用到了group by字句

{%folding green, group by字句%}

```sql
SELECT 
	client_id,
	SUM(invoice_total) AS total_sales
FROM invoices
GROUP BY client_id
ORDER BY total_sales DESC
```

{%note simple info %} select子句后的任一非聚合函数字段都应来源于group by 分组语句后，否则语法会编译不通过。一般来说，group by后面跟的就是select的所有列 ，在group by后面可以跟**having** 字句来筛选结果2，后面跟**with rollup** 字句会对数据进行求和并放在最后一列{%endnote%}

。

{%endfolding%}

{%endfolding%}

{%folding,IF和CASE条件判断查询%}

**IF条件判断查询**

类似于三元运算符，如果order_date大于等于2019，则是活跃用户，否则是不活跃用户

```sql
SELECT 
	order_id,
	order_date,
	if(YEAR(order_date) >= (YEAR(NOW())-3), '活跃','不活跃') AS '活跃度' 
FROM orders
```

输出结果：

1	2019-01-30	活跃
2	2018-08-02	不活跃
3	2017-12-01	不活跃
4	2017-01-22	不活跃
5	2017-08-25	不活跃
6	2018-11-18	不活跃
7	2018-09-22	不活跃
8	2018-06-08	不活跃
9	2017-07-05	不活跃
10	2018-04-22	不活跃

**case 条件判断字句**

```sql
SELECT
	CONCAT(first_name,' ',last_name) AS name,
	points,
	CASE
		WHEN (points>3000) THEN '黄金'
		WHEN (points>2000) THEN '白银'
		ELSE '青铜'
	END AS '分类'
FROM customers
ORDER BY points DESC
```

输出结果：

Clemmie Betchley	3675	黄金
Elka Twiddell	3073	黄金
Freddi Boagey	2967	白银
Babara MacCaffrey	2273	白银
Ilene Dowson	1672	青铜
Romola Rumgay	1486	青铜
Ines Brushfield	947	青铜
Levy Mynett	796	青铜
Ambur Roseburgh	457	青铜
Thacher Naseby	205	青铜

{%endfolding%}

##### 连接查询

{%folding green, 内连接查询(inner join)%}

- 例如查询id，firstname和lastname从orders表和customers表

```sql
SELECT order_id,first_name,last_name
FROM orders
INNER JOIN customers
	ON orders.customer_id = customers.customer_id
```

{%note info simple%}如果查询的列在两张表中有相同的名字，需要指定表前缀,例如orders.customer_id {%endnote%}

- 跨数据库连接，只需要在表前加上数据库的前缀即可

```sql
SELECT *
FROM sql_store.order_items oi
JOIN sql_inventory.products p
	on oi.product_id=p.product_id
```

- 复合连接条件，当连接的表中有两个主键时

```sql
SELECT *
FROM order_items oi
JOIN order_item_notes oin
	ON oi.order_id = oin.order_Id
	AND oi.product_id = oin.product_id
```

{% note info simple %}以上的表连接方式都属于显式连接语法，下面介绍隐式连接语法{% endnote %}

隐式连接语法就是用where代替join 和on，如上一条语句可以改写成下面的语句

```sql
SELECT *
FROM order_items oi,order_item_notes oin
WHERE oi.order_id = oin.order_Id
AND oi.product_id = oin.product_id
```

{% note info simple %}显然是显式连接语法更好一些，因为在隐式连接语法中可能都是where导致结果是笛卡尔积二显式连接语法在丢失on字句后会报错，避免发生错误的结果{% endnote %}

{%endfolding%}

{%folding green, 外连接查询(outer join)%}

外连接有两种方式：左外连接(left join)和右外连接(right join)

在使用左外连接时，不管右表中有没有记录，所有左表的记录都会被返回，部分右表的记录可能是空的

```sql
SELECT 
	c.customer_id,
	c.first_name,
	o.order_id
FROM orders o
RIGHT JOIN customers c
	ON c.customer_id = o.customer_id
ORDER BY c.customer_id
```

right join 实际上是right outer join ，其中outer是可以省略的，就像内连接中inner可以省略一样

{%folding green, 自连接查询%}

为什么要有自连接查询？

因为在一张表中，可能有员工和领导，要查询所有员工对应的领导及ID，但表的一行中没有领导的ID，这时就用到了自连接查询

```sql
SELECT
	e.employee_id,
	e.first_name,
m.first_name AS manger
FROM employees e
LEFT JOIN employees m
	on e.reports_to = m.employee_id
```

{%endfolding%}

{%endfolding%}

{%folding,USING字句%}

使用using字句可以简化on字句

例如两张表中都有customer_id

```sql
SELECT
	o.order_id,
	c.first_name
FROM orders o
JOIN customers c
	USING (customer_id)
JOIN shippers shippers
	USING (shipper_id)
```

{% note info simple %}只有两个表的字段名称相同时才可以使用 {%endnote%}

{%endfolding%}

{%folding ,自然连接(系统看着办)%}

```sql
SELECT 
	o.order_id,
	c.first_name
FROM orders o
NATURAL JOIN customers c
```

{%endfolding%}

{%folding ,联合查询(UNIONS)%}

```sql
SELECT first_name
FROM customers
UNION
SELECT name
FROM shippers
```

可以联合多个查询的结果

{%endfolding%}

##### 嵌套查询

如：

​	select sno,sname,sdept from student where sdept in

​	(select sdept from student where sname = '刘晨');

{%folding ,all/any字句：%}

- 查询其他系中比cs系**某一学生** 年龄小的学生姓名和年龄

```sql
select sname,sage 
from student 
where sage < any (
    select sage from student where sdept='cs'
) 
and sdept <> 'cs';
```

>  any代表某一，all代表全部

{%endfolding%}

{%folding ,字句中的子查询%}

```sql
SELECT 
	invoice_id,
	invoice_total,
	(SELECT AVG(invoice_total) FROM invoices) AS invoice_average,
	invoice_total - (SELECT invoice_average)
FROM invoices
```

之所以在`(SELECT invoice_average)`之前加上select是因为，只有加了select才能使用子查询的别名

{%endfolding%}





##### 带有exists谓词的相关子查询

![](https://s1.ax1x.com/2022/05/30/X10qfO.png)

**主要是解决“至少选择了”、“只选择了”和“选择了全部”类似的问题**

例如：

<img src="https://s1.ax1x.com/2022/05/30/X1BvCT.png" width="80%" />

<img src="https://s1.ax1x.com/2022/05/30/X1Dxot.png" width="80%"  />

<img src="https://s1.ax1x.com/2022/05/30/X1r1OJ.png" width="80%"  />

**关于exists和not exists的一些理解**

这里的exists和not exists有些绕，我加入了一些自己的理解：

比如上面的例子，可以理解为一条一条数据来判断，从最外层开始，首先查询所有的学号sno，传入下一层的是第一个sno，接下来对这个sno进行判断，

下一层select中查询出来的是学号为‘20021522’学生所选全部课程，传入下一层的是第一个sno+第一个课程cno

最后一层进行判断，sno是否选修了cno，接下来判断sno是否选修了cno2，依次类推，如果都选修了，那么最后一层传出的是false(因为是not exists)，再往上一层传的是ture(又是not exits)，所以这条数据就被保留了，接下来就是第二个学生sno2传入下一层，

以此类推，就可以找出所有“至少选修了所有学号为‘200215122’学生选修课程的学生”

{% note info simple %}使用in和not in同样可以得到相同的结果，但是使用exists字句返回的是真假值，使用in字句返回的是一个结果集，所以从性能上来说，exists会更好一些{%endnote%}

#### 插入

insert into 表名[(字段列表)] values (值列表)

**多表插入**

适用于有母表和子表的数据库插入，插入母表的同时也插入一行或者多行子表数据

可以使用MySQL中的函数： LAST_INSTER_ID()来获取上次插入数据的ID值，再根据这个ID值向子表中插入数据

#### 修改

update 表名 set 字段1=值，字段2=值...where 条件

#### 删除

delete from 表名 [where 条件]

#### **MySQL常用函数**

https://www.runoob.com/mysql/mysql-functions.html

#### MySQL视图

视图存储的并不是数据，而是查询语句，它是为了避免我们写重复的查询语句。所以当表更新时，视图也会随着更新

{%folding green,视图操作%}

**创建视图**

基本语法`CREATE VIEW view_name as 查询语句`

```sql
CREATE VIEW sales_by_client AS
SELECT 
	c.client_id,
	c.name,
SUM(invoice_total) AS total_sale
FROM clients c
JOIN invoices i USING (client_id)
GROUP BY client_id,name
```

**删除视图**

基本语法： `DROP VIEW sales_by_client`

**可更新视图**

什么是可更新视图：

就是在视图中没有用到任何聚合函数（sum、count等）、group by字句、union字句、ORDER BY子句、HAVING子句，这样的视图是可更新视图。

可更新视图可以更新视图，像对表那样的操作一样，对视图的操作会影响到表的数据

> 更新视图后一些行可能不满足where条件但是依然在视图中存在，这时可以在更新语句的最后加上with check option



{%endfolding%}

#### MySQL常用数据类型

**Strings**

CHAR 存储固定长度的字符串

VARCHAR 存储可变长度字符串(用户名，密码，电子邮箱，地址等)

- 最大长度：65535(64kb)

如果需要更长的字符串：

MEDIUMTEXT最大容量：16MB

LONGTEXT最大容量：4GB

此外TINYTEXT可以存储255 bytes，TEXT可以存储64KB

常用标准：

- VARCHAR(50) 用于短字符串 
- VARCHAR(255)用于长字符串

英文通常占用1字节，中文占用3字节，如果是VARCHAR(10),MySQL会留出30字节

**Integers**

| 整数类型         | 存储字节 | 表示范围   |
| ---------------- | -------- | ---------- |
| TINYINT          | 1B       | [-128,127] |
| UNSIGNED TINYINT |          | [0,255]    |
| SMALLINT         | 2B       | [-32k,32k] |
| MEDIUMINT        | 3B       | [-8M,8M]   |
| INT              | 4B       | [-2B,2B]   |
| BIGINT           | 8B       | [-9Z,9Z]   |

**Rationals**

DECIMAL(p,s)	例如 DECIMAL(9,2)=>1234567.89

DEC

NUMERIC

FIXED

FLOAT 占用4b，可以存储更精确的数字

DOUBLE 占用8b

**Booleans**

BOOL

BOOLEAN

**Enum and Set Types**

避免使用

**Date and Time Types**

DATE

TIME

DATETIME       	8b

TIMESTAMP        	4b （只能存到2038年）

YEAR

**Blobs**

存储二进制数据，但是最好不要用

TINYBLOB 255b

BLOB 65KB

MEDIUMNLOB 16MB

LONGBLOB 4GB

**JSON**



## 五、数据库的完整性

### 三大完整性

1. 实体完整性

   主码唯一且非空

2. 参照完整性

   外码要么为空，要么对应另一表的主码

3. 用户定义完整性

   实体的属性要完整，比如学号多少，姓名，班级，专业之类

   - 非空
   - 列表唯一
   - 满足某一个条件表达式 如性别只有男女之分

### 断言

断言assertion

格式： create assertion <断言名> <check子句>

### 触发器

触发器即 事件->条件->动作

当对一个表中增删改时，对触发器里面的条件进行检查，如果成立就执行触发器里面的动作，否则不执行

格式：

```sql
create trigger <触发器名>    /*每当触发事件发生时，该触发器被激活*/

{before|after} <触发事件> on <表名> /*指明触发器激活时间是在执行触发器前或后*/

referencing {new|old} row as <变量>/*referencing 指出引用的变量*/

for each{row|statement} /*定义触发器的类型，指明动作体执行的频率*/

[where<触发条件>] <触发动作体>/*仅当触发条件为真时才会触发动作体*/
```

## 六、关系数据理论

### 依赖

- 非平凡的函数依赖

  X->Y，但Y不属于X，则称X->Y是一个非平凡的函数依赖

- 平凡的函数依赖

  X->Y，且Y属于X，X->Y是一个平凡的函数依赖

如下面的例子中，A和D是平凡函数依赖，而BC是非平凡函数依赖

![](https://s1.ax1x.com/2022/06/10/X68Nex.png)

#### 完全函数依赖和部分函数依赖

<img src="https://s1.ax1x.com/2022/05/31/X8bTER.png" width="67%" />

#### 传递函数依赖

<img src="https://s1.ax1x.com/2022/05/31/X8bxDH.png" width="67%" />



### 候选码

候选码：若关系中的一个属性或属性组的值能够唯一地标识一个元组，且他的真子集不能唯一的标识一个元组，则称这个属性或属性组做候选码。

选候选码

1. 只出现在左边的一定是候选码(包括未出现的)
2. 只出现在右边的一定不是候选码
3. 左右都出现的不一定
4. 左右都不出现的一定是候选码
4. 再求确定的候选码的闭包，如果可以推出全部，那么当前确定的就是候选码；否则，要把每一个可能的值放进当前确定的候选码中进行求闭包。

{% note info simple %}

(1)L类：仅仅出现在F中的函数依赖左部的属性

(2) R类：仅仅出现在F中的函数依赖右部的属性

(3) N类：不出现在F中的函数中的属性

(4) LR类：出现在F中的函数依赖左部又出现在右部的属性

{% endnote %}

{% folding 结论 %}

结论：
(1) 若X是L类属性：则X必然属于任一候选键的成员
(5) 若X是L类属性：且X包含了R的所有属性，则X必然属于唯一候选键
(2) 若X是R类属性：则X不属于任何候选键
(3) 若X是N类属性：则X必然属于任一候选键的成员
(4) 若X是LR类属性：且X包含了R的所有属性，则X必然属于唯一候选键

{% endfolding %}

{% folding green, 案例 %}

**案例**

![](https://s1.ax1x.com/2022/05/31/XGFXxH.md.jpg)

<img src="https://s1.ax1x.com/2022/05/31/XGkYLR.jpg" width="40%" />

{% endfolding %}

- 超码：包含候选码的集合,也就是能够表示出所有属性的集合，候选码是最小的超码
- 主码：候选码中的任意一个都是主码
- 主属性：包含所有候选码的属性
- 非主属性：除去所有候选码的属性
- 全码：所有属性都是主码

### 三大范式

范式是符合某一种**级别** 的关系模式的集合

关系数据库中的关系**必须满足一定的要求** 。满足不同程度要求的为不同范式

{% folding green,范式的种类 %}

 第一范式(1NF) 

第二范式(2NF) 

第三范式(3NF)

 BC范式(BCNF)

 第四范式(4NF)  

第五范式(5NF)

只需知道BC范式以上即可

{% endfolding %}

**1NF**

所有字段值都是不可再分的原子值

如地址和省份城市详细地址的关系

> 第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库

**2NF**

一个表只能包含一种数据，不可以把多种数据保存在同一张表中,即每一个**非主属性完全函数依赖** 于码

换句话说，就是一张表只能代表一种实体类型，这张表中的每一列都应该用来描述那个实体,如果有其他类型的数据，要单独放到一张表当中

**3NF**

确保数据表中的每一列数据都和主键直接相关，而不能间接相关，也就是不存在非主属性传递依赖于R的候选码。

比如一张表中有first_name和last_name，那么name就应该删去，因为修改firstname或者lastname都会导致name和表不一致

**BCNF**

消除每一属性对候选码的传递依赖，函数依赖的左边只能是超码（包含候选码），BCNF是修正的第三范式

**判断范式**

![](https://s1.ax1x.com/2022/06/11/Xcx6Z6.png)

### 最小依赖集

1. 拆右边为多个元素 如A->BC 拆为A->B A->C
2. 除去当前左边元素，求它的闭包，依次求完
3. 左边最小化，如BCD，遮住B看CD能推出B吗，如果能就把B去掉

![](https://s1.ax1x.com/2022/06/01/XGDhNR.jpg)

{% folding green, 解题过程 %}

<img src="https://s1.ax1x.com/2022/06/01/XGscTJ.md.jpg" width="80%" />

{% endfolding %}

### 模式分解

{% tabs test4 %}
<!-- tab 准则 -->
准则： 无损连接 和 保持函数依赖
<!-- endtab -->

<!-- tab 无损 -->
无损： 就是分解后再次连接，和分解之前一样
<!-- endtab -->

<!-- tab 依赖 -->
依赖：依赖不变
<!-- endtab -->

{% endtabs %}

{% checkbox green checked, 1. 求出最小依赖集%}

{% checkbox green checked, 2. 把不在关系里的属性找出来，单独分成一类%}

{% checkbox green checked, 3. 把每一个左边相同的分成一类，如A->B变为AB,如果是A->B,A->C，则改为ABC%}

{% checkbox green checked, 4. 如果候选码没有在里面，把任意一个候选码作为一类%}

{% tip info %}例题部分{% endtip %}

{% tabs test4 %}
<!-- tab 例题一 -->
设关系模式为 R<U，F>， U＝{A，B，C，D，E，P }，
       F＝{A→D，E→D，D→B，BC→D，DC→A } 
（1）求(AD)+；
（2）求R的候选码，指出哪些属性是主属性，哪些是非主属性。
（3）判断是第几NF

{% folding green, 解答 %}
<img src="https://s1.ax1x.com/2022/06/01/XGL4IA.md.jpg" width="50%"/>

{% endfolding %}

<!-- endtab -->

<!-- tab 例题二 -->

2. 设有关系模式R<U, F>，其中U={A,B,C,D,E}，F={A→C, B→AC, D→AC, E→B}，试求:
(1)求出候选码；（3分）
(2)判断关系R是第几NF。（3分） 

{% folding green, 解答 %}

<img src="https://s1.ax1x.com/2022/06/01/XGODeg.md.jpg" width="50%" />

{% endfolding %}

<!-- endtab -->

<!-- tab 例题三 -->

<!-- endtab -->
{% endtabs %}

## 七、数据库设计

### 数据库设计的基本步骤

1. 需求分析
2. 概念结构设计 ：ER图或者是设计数据字典
3. 逻辑结构设计 ：把ER图转为逻辑模型
4. 物理结构设计 ：把逻辑模型转为物理模型
5. 数据库实施   ：写SQL代码
6. 数据库运行维护

### ER图

- 实体是长方形
- 属性是椭圆形
- 关系式菱形

### ER图转关系模型

- 1对1：要把关系合并到任意一个表，并且把另外的表里面的主键放到另外一个里面
- 1对n：把1的主码放到n里面，然后把关系的属性放到n里面
- m对n：需要两边的实体主键和自身的属性单独作为一个关系模式



{% tip info %}例题部分{% endtip %}

{% tabs test3 %}
<!-- tab 例题一 -->

设在需求分析阶段，经初步分析，有如下实体及其属性： 

学生：学号、学院、姓名、性别、年龄、选修课程名
课程：编号、课程名、开课学院、任课教师号
教师：教师号、姓名、性别、职称、讲授课程编号
学院：学院名称、电话、教师号、教师名
调研后确定系统中存在如下联系：
（1）一个学生可选修多门课程，一门课程可为多个学生选修；
（2）一个教师可讲授多门课程，一门课程可为多个教师讲授；
（3）一个学院可有多个教师，一个教师只能属于一个学院。
试完成如下设计：
（1）设计包括各实体及其联系的全局E-R图（为避免E-R图图形复杂，可省去实体属性，注意：需求分析的实体属性仅为初步分析，存在重复和多余属性） （12分）
（2）将该全局E-R图转换为等价的关系模型表示的数据库逻辑结构。(6分)

{% folding green, 解答 %}

![](https://s1.ax1x.com/2022/06/01/XJgYsx.png)

(2)  关系模式
学院（学院名，电话）                             
教师（教师号，姓名，性别，职称，学院名）             
课程（课程编号，课程名，学院名）
学生（学号，姓名，性别，年龄，学院名）
讲授（教师号，课程编号）   
选修（学号，课程编号）                           

{% endfolding %}

<!-- endtab -->

<!-- tab 例题二 -->

销售部门管理系统数据库设计：（共15分）
假定一个部门的数据库包括以下信息： 
a. 职工的信息：职工号、姓名、地址。
b. 部门的信息：部门号、部门名、经理。
c. 产品的信息：产品名、产品内部编号。
d. 制造商的信息：制造商名称、地址。
需求分析：一个部门有多个职工，每个职工只属于一个部门； 每种产品可以由不同部门销售，一个部门可以销售多种产品；每种产品可以由不同制造商生产，每个制造商可以生产多种产品，每个制造商生产的每种产品对应不同价格。
要求：（1）根据上述语义画出E-R图；（9分）
     （2）将E-R图转换成对应的关系模式并标注每个关系的主码。(6分)

{% folding green, 解答 %}

![](https://s1.ax1x.com/2022/06/01/XJ28AS.md.png)

关系模式：
    职工（职工号，姓名，地址，所在部门）                    -----1分
   部门（部门号，部门名称、经理）                 -----1分
   产品（产品内部编号，产品名称）                -----1分
   制造商（制造商名称，地址）                    -----1分
   销售（部门号，产品内部编号）                   -----1分
   生产（制造商名称，产品内部编号，价格）         -----1分

{% endfolding %}

<!-- endtab -->

<!-- tab 例题三 -->

![](https://s1.ax1x.com/2022/06/01/XJR0xA.md.jpg)

<!-- endtab -->
{% endtabs %}

## 九、关系查询处理和查询优化

{% folding ,查询过程 %}

![](https://s1.ax1x.com/2022/06/01/XJWJQs.png)

{% endfolding %}

{% folding,优化原则%}

1. 选择运算尽量先做
2. 把投影和连接同时执行
3. 把投影同它前后的双目运算符连接起来

{% endfolding %}

{% folding,案例 %}

![](https://s1.ax1x.com/2022/06/01/XJfXuR.png)

优化后：

![](https://s1.ax1x.com/2022/06/01/XJhSUK.png)

{% endfolding %}



## 十、数据库恢复技术

### 事务

**定义**：

- 一个数据库操作序列（顺序的SQL语句集合）
-  一个不可分割的工作单位
- 恢复和并发控制的基本单位

#### 事务的ACID特性

- 原子性（Atomicity）  逻辑工作单位
- 一致性（Consistency）执行结果的一致性
- 隔离性（Isolation） 事务之间不能互相干扰
- 持续性（Durability ）改变是永久的

#### 恢复策略

{% folding,恢复策略 %}

事务故障的恢复：事务异常终止，那么撤销之前所有的操作

系统故障的恢复：还没执行完的事务UNDO，丢失的事务REDO

介质故障的恢复：重装数据库，重做已经做完的事务

{% endfolding %}

![](https://s1.ax1x.com/2022/06/01/XJhLi8.png)

##  十一、并发控制

### 并发带来的问题

{% tip error %}1、丢失修改：修改的东西没生效{% endtip %}

{% tip error %}2、读脏数据：数据正在更新时被读取，数据就是脏数据{% endtip %}

比如下面的场景：事务隔离级别：READ UNCOMMITTED

一个用户正在执行下列语句：

```sql
USE sql_store;
START TRANSACTION;
UPDATE customers
SET points = 200
WHERE customer_id = 1;
ROLLBACK;
```

当执行到第三行时，又有一个用户执行下面的语句：

```sql
USE sql_store;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT points
FROM customers
WHERE customer_id = 1
```

> 上面的这个语句是读取未提交隔离级别，所以在事务执行中就能够读取到，是脏数据，因为后面事务又回滚了。

{% tip error %}3、不可重复读：在一个事务中两次读取数据不一致{% endtip %}

{% tip error %}4、幻读 修改在统计之前，但是统计时并没有统计到被修改的数据{% endtip %}

### 解决办法

1. 排它锁(Exclusive Locks)，也叫写锁，X锁，写锁会把读和写都阻塞
2. 共享锁(Share Locks)，也叫读锁，S锁，读锁会阻塞写，但是不会阻塞读

### 封锁协议

{% tabs test1 %}
<!-- tab 一级封锁协议 -->
修改时必须加X锁，直到结束

将事务设置成**READ UCOMMITTED隔离级别**

![](https://s1.ax1x.com/2022/06/10/Xc9gM9.png)

{% note default simple %}解决丢失修改问题，但是我们发现A=20其实是个脏数据，因为事务A回滚了， 在1级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读"脏"数据。{% endnote %}

<!-- endtab -->

<!-- tab 二级封锁协议 -->

要求修改数据时必须加X锁，直到事务结束才释放锁 

读的时候，加S锁，用完就放

也就是将事务设置为**READ COMMITED隔离级别**

![](https://s1.ax1x.com/2022/06/11/XcuL9A.png)

{% note default simple %}解决读脏数据问题，但是可能存在不可重复读的问题，具体看以下图{% endnote %}

![](https://s1.ax1x.com/2022/06/10/XcCwyd.png)

两次读取到的A并不同，这就是不可重复读

<!-- endtab -->

<!-- tab 三级封锁协议 -->

要求修改数据时必须加X锁，直到事务结束才释放锁 

读的时候，加S锁，直到结束

将事务设置为**REPETABLE READ事务隔离级别**

![](https://s1.ax1x.com/2022/06/11/XcKuEF.png)

{% note default simple %}解决不可重复读问题，但是这又导致了另外一个问题——幻读，也就是下图所示，修改了A但是在统计时并未发现A（见鬼了），所以称为幻读{% endnote %}

![](https://s1.ax1x.com/2022/06/11/XcKUED.png)

<!-- endtab -->

{% endtabs %}

**解决幻读问题**

将事务设置成**SERIALIZABLE事务隔离级别** ，也就是序列化操作

![](https://s1.ax1x.com/2022/06/11/XcKqVU.png)

> 但是序列化操作会带来新的问题，那就是死锁，也就是死循环的锁

![](https://s1.ax1x.com/2022/06/11/XcYD2D.png)

> 　减少死锁问题的几种方法：
>
> １.　让用户重试
>
> ２.　在更新多条数据时，按照相同的顺序执行
>
> ３.　简化事务，减少单条事务更新数量，缩短事务运行时间

![](https://s1.ax1x.com/2022/06/01/XJ5fud.md.jpg)

查看当前事务隔离级别：

```sql
SHOW VARIABLES LIKE 'transaction_isolation'
```

设置事务的隔离级别

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

> 如果在set后面加上session关键字，则未来的事务都会被设置成当前级别
>
> 如果在set后面加上global关键字，则全部事务都被设置成当前级别

