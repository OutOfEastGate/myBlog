---
title: 算法学习笔记
date: 2022-06-04 21:48:39
tags: 算法
categories: 学习笔记-算法
cover: http://www.wanghongtao.xyz/52b00563-64fd-446a-9bee-d1cff2a8b389.png
---

https://nyimac.gitee.io/2020/06/17/数据结构与算法/

线性数据结构：数组、队列、链表、栈

非线性数据结构：二维数组、多维数组、广义表、树结构、图结构

## 数据结构

### 稀疏数组

稀疏数组：防止存储一些无意义的数据

![](https://s1.ax1x.com/2022/06/07/XDeJud.png)

应用实例：

- 使用稀疏数组保存棋盘、地图等二维数组
- 把稀疏数组存盘并且可以恢复成原来的二维数组

转换思路：

{%tabs 1%}

<!--tab 二维数组转稀疏数组-->

- 遍历二维数组，得到二维数组中有效值的个数sum
- 创建稀疏数组，有sum+1行，3列（固定）
- 将二维数组中的有效值存入稀疏数组中

<!--endtab-->

<!--tab 稀疏数组转二维数组-->

- 先读取稀疏数组的第一行（保存二维数组的行列信息），还原二维数组
- 读取稀疏数组的其他行，将值赋给二维数组的对应位置上的数

<!--endtab-->

{%endtabs%}

{% folding green,代码实现 %}

1. 用list+自定义数据结构实现，中间有很多坑，建议使用二维数组

```java
package javaTest;

public class test1 {
    //用于存储稀疏数组
    public static class datas{
        int row;
        int column;
        int val;
    }
    public static void main(String[] args) {
        int array[][] = new int[11][11];
        array[1][2] = 1;
        array[2][4] = 2;
        //输出原始数组
        System.out.println("原始二维数组：");
        for(int[] row:array){
            for(int data:row){
                System.out.print(data+" ");
            }
            System.out.println();
        }
        //sum代表数组中有效值的个数
        int sum = 0;
        for(int[] row:array){
            for(int data:row){
                if(data!=0)
                sum++;
            }
        }
        //创建稀疏数组
        List<datas> list = new ArrayList<>();
        datas item = new datas();
        item.column=11; 
        item.row=11;
        item.val=sum;
        list.add(item);
        int p=1;
        for(int i = 0;i<array.length;i++){
            for(int j = 0;j<array.length;j++){
                if(array[i][j]!=0){
                    datas item2 = new datas();
                    item2.row=i; 
                    item2.column=j;
                    item2.val=array[i][j];
                    list.add(item2);
                }   
            }
        }
        System.out.println("稀疏数组：");
        for(datas d:list){
            System.out.print(d.row+" ");
            System.out.print(d.column+" ");
            System.out.println(d.val);
        }
        //将稀疏数组还原为二维数组
        System.out.println("稀疏数组还原为二维数组");
        int array2[][] = new int[11][11];
        for(int i=1;i<list.size();i++){
            int row = list.get(i).row;
            int column = list.get(i).column;
            int val = list.get(i).val;
            array2[row][column] = val;
        }
        for(int[] row:array2){
            for(int data:row){
                System.out.print(data+" ");
            }
            System.out.println();
        }
    }
}

```

2. 用二维数组实现

```java
package javaTest;

import java.util.ArrayList;
import java.util.List;

public class test1 {
    public static void main(String[] args) {
        int array[][] = new int[11][11];
        array[1][2] = 1;
        array[2][4] = 2;
        //输出原始数组
        System.out.println("原始二维数组：");
        for(int[] row:array){
            for(int data:row){
                System.out.print(data+" ");
            }
            System.out.println();
        }
        //sum代表数组中有效值的个数
        int sum = 0;
        for(int[] row:array){
            for(int data:row){
                if(data!=0)
                sum++;
            }
        }
        //创建稀疏数组
        int result[][] = new int[sum+1][3];
        result[0][0]=11;
        result[0][1]=11;
        result[0][2]=sum;
        int p=1;//用于指向稀疏数组
        for(int i=0;i<array.length;i++){
            for(int j=1;j<array.length;j++){
                if(array[i][j]!=0){
                    result[p][0]=i;
                    result[p][1]=j;
                    result[p][2]=array[i][j];
                    p++;
                }
            }
        }
        System.out.println("稀疏数组：");
        for(int[] re:result){
            for(int e:re){
                System.out.print(e+" ");
            }
            System.out.println();
        }
        //将稀疏数组还原为二维数组
        int[][] ret = new int[11][11];
        for(int i=1;i<result.length;i++){
                ret[result[i][0]][result[i][1]]=result[i][2];
            }
            System.out.println("还原为二维数组");
        for(int[] row:ret){
            for(int data:row){
                System.out.print(data+" ");
            }
            System.out.println();
        }
    }
}
```

输出结果：

```
原始二维数组：
0 0 0 0 0 0 0 0 0 0 0 
0 0 1 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
稀疏数组：
11 11 2
1 2 1
2 4 2
还原为二维数组
0 0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
```

{% endfolding %}

### 队列

定义：

- 队列是一个**有序列表**，可以用**数组**或是**链表**来实现。
- 遵循**先入先出**的原则。即：先存入队列的数据，要先取出。后存入的要后取出

{%folding green,代码实现%}

```java
package javaTest.main;

import java.util.Scanner;

public class queue {
    public static void main(String[] args) {
        ArrayQueue arrayQueue = new ArrayQueue(10);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while(loop){
            System.out.println("s(show) 显示队列");
            System.out.println("e(exit) 退出");
            System.out.println("a(add) 添加队列");
            System.out.println("g(get) 获取队列元素");
            System.out.println("h(head) 获取头部");
            System.out.println("请输入：");
            key = scanner.next().charAt(0);
            switch (key) {
                case 'e':
                    scanner.close();
                    System.out.println("程序退出");
                    loop=false;
                    break;
                case 's':
                try {
                    arrayQueue.showQueue();
                } catch (Exception e) {
                    System.out.println(e.getMessage());
                }
                    break;
                case 'a':
                    int temp = scanner.nextInt();
                    arrayQueue.addQueue(temp);
                    break;
                case 'g'://取出数据可能有异常
                    try {
                        arrayQueue.getQueue();
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                        //TODO: handle exception
                    }
                    break;
                case 'h':
                    try {
                        System.out.println( arrayQueue.getHead());
                    } catch (Exception e) {
                        e.getMessage();
                    }
                    break;
                default:
                System.out.println("输入有误");
                    break;
            } 
        }

    }
}

class ArrayQueue {
    private int maxSize;
    private int rear;//队尾
    private int front;//对头
    private int[] arr;//存放数据的模拟队列

    /**
     * 构造函数
     * @param maxSize
     * 
     */
    public ArrayQueue(int maxSize){
        this.maxSize=maxSize;
        rear=front=-1;//给定初始值为-1
        arr = new int[maxSize];
    }
    public boolean isFull(){
        if(rear==maxSize-1) return true;
        return false;
    }
    public boolean isEmpty(){
        if(rear==front) return true;
        return false;
    }
    //添加队列
    public boolean addQueue(int item){
        if(isFull()){
            System.out.println("队列已满，添加失败");
            return false;
        }
        rear++;
        arr[rear] = item;
        return true;
    }
    //出队列
    public boolean getQueue(){
        if(isEmpty()){
            System.out.println("队列为空，获取失败");
            return false;
        }
        front++;
        System.out.println(arr[front]);
        return true;
    }
    //显示所有队列
    public void showQueue(){
        if(isEmpty()){
            throw new  RuntimeException("队列为空");
        }
        for(int i = front+1;i<=rear;i++){
            System.out.print(arr[i]+" ");
        }
        System.out.println();
    }
    public int getHead(){
        if(isEmpty()){
            throw new RuntimeException("队列为空");
        }
        return arr[front+1];
    }
}
```

输出结果

```
s(show) 显示队列
e(exit) 退出
a(add) 添加队列
g(get) 获取队列元素
h(head) 获取头部
请输入：
a
1

请输入：
a
2

请输入：
a
3

请输入：
s
1 2 3 

请输入：
g
1

请输入：
s
2 3 

```

{%endfolding%}

#### 循环队列

在上面的队列中，我们发现，有一些空间是被浪费的。所以我们可以在逻辑上把一个队列看成一个环形的队列，这样即使后面的空间用完，也可以接着前面出队列剩余的空间继续存储。

思路：

1. 原先的front指针指向队首元素的前一个，也就是在出队列时需要front++，再出队列。
2. 原先的rear指针指向队尾元素，也就是在入队时需要rear++，再入队。
3. 循环队列的front指向队首元素，rear指向队尾元素的后一个空位值
4. 循环队列满的条件是(rear+1)%maxSize = front

> 分析以上思路可知，当循环队列满时，实际上还有一个空位，也就是rear的位置是空的，之所以要空出来是为了不让rear和front指向同一块位置，这样的话就不会因为rear==front而认为队列为空

循环队列满的状态如图：

<img src="https://s1.ax1x.com/2022/06/09/XsjZ9I.png" width="50%" />



> 队列中有效元素个数是(rear+maxSize-front)%maxSize



{%folding green,代码实现%}

```java
package javaTest.main;

import java.util.Scanner;

public class queue {
    public static void main(String[] args) {
        ArrayQueue arrayQueue = new ArrayQueue(10);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while(loop){
            System.out.println("s(show) 显示队列");
            System.out.println("e(exit) 退出");
            System.out.println("a(add) 添加队列");
            System.out.println("g(get) 获取队列元素");
            System.out.println("h(head) 获取头部");
            System.out.println("请输入：");
            key = scanner.next().charAt(0);
            switch (key) {
                case 'e':
                    scanner.close();
                    System.out.println("程序退出");
                    loop=false;
                    break;
                case 's':
                try {
                    arrayQueue.showQueue();
                } catch (Exception e) {
                    System.out.println(e.getMessage());
                }
                    break;
                case 'a':
                    int temp = scanner.nextInt();
                    try {
                        arrayQueue.addQueue(temp);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'g'://取出数据可能有异常
                    try {
                        arrayQueue.getQueue();
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                        //TODO: handle exception
                    }
                    break;
                case 'h':
                    try {
                        System.out.println( arrayQueue.getHead());
                    } catch (Exception e) {
                        e.getMessage();
                    }
                    break;
                default:
                System.out.println("输入有误");
                    break;
            } 
        }

    }
}

class ArrayQueue {
    private int maxSize;
    private int rear;//队尾
    private int front;//对头
    private int[] arr;//存放数据的模拟队列

    /**
     * 构造函数
     * @param maxSize
     * 
     */
    public ArrayQueue(int maxSize){
        this.maxSize=maxSize;
        rear=front=0;//循环队列给定初始值为0
        arr = new int[maxSize];
    }
    public boolean isFull(){
        if((rear+1)%maxSize==front) return true;
        return false;
    }
    public boolean isEmpty(){
        if(rear==front) return true;
        return false;
    }
    //添加队列
    public boolean addQueue(int item){
        if(isFull()){
            throw new RuntimeException("队列已满，添加失败");
        }
        arr[rear%maxSize] = item;
        rear++;
        return true;
    }
    //出队列
    public boolean getQueue(){
        if(isEmpty()){
            System.out.println("队列为空，获取失败");
            return false;
        }
        System.out.println(arr[front]);
        front++;
        return true;
    }
    //显示所有队列
    public void showQueue(){
        if(isEmpty()){
            throw new  RuntimeException("队列为空");
        }
        int frequency = (rear+maxSize-front)%maxSize;
        int i=front;
        while(frequency!=0){
            System.out.print(arr[i]+" ");
            i++;
            i=i%maxSize;
            frequency--;
        }
        System.out.println();
    }
    public int getHead(){
        if(isEmpty()){
            throw new RuntimeException("队列为空");
        }
        return arr[front];
    }
}
```

{%endfolding%}

### 链表

- 链表是以节点的方式来存储,**是链式存储**
- 每个节点包含 data 域 和 next 域。next域用来指向下一个节点
- 链表的各个节点不一定是连续存储的
- 链表分**带头节点的链表**和**没有头节点的链表**，根据实际的需求来确定

![](https://s1.ax1x.com/2022/06/09/XykI3D.png)

{%folding green,无顺序链表代码实现%}

```java
public class NodeList {
    public static void main(String[] args) {
        People headNode = new People(0," "," ");
        People p1 = new People(1,"wht","m");
        People p2 = new People(2,"wht2","m");
        People p3 = new People(3,"wht3","f");
        headNode.Add(headNode,p1);
        headNode.Add(headNode,p3);
        headNode.Add(headNode,p2);
        headNode.ShowList(headNode);

    }
}

class People {
    int id;
    String name;
    String sex;
    People next;

    public People(int id,String name,String sex){
        this.id=id;
        this.name = name;
        this.sex=sex;
        next = null;
    }
    public void Add(People headNode,People newPeople){
        if(headNode.next==null) {
            headNode.next = newPeople;
        }else{
            People temp = headNode;
            while(true){
                if(temp.next==null){
                    temp.next = newPeople;
                    break;
                }
                temp = temp.next;
            }
        }
    }//Add

    public void  ShowList(People headList) {
        People temp = headList.next;
        while(temp!=null){
            System.out.print(temp);
            temp=temp.next;
        }
    }

    @Override
    public String toString() {
        return "["+
                "id=" + id +
                ", name='" + name + '\'' +
                ", sex=" + sex + "]" +'\n';
    }
}
```

{%endfolding%}

**有顺序链表**

所谓有顺序链表是指在插入时按照一定次序规则插入，比如id值

思路分析：

1. 首先让一个temp等于headNode
2. 只要temp.next的id小于newNode的id，就让temp往后移动，如果temp.next为空，需要跳出循环，因为这时需要插入链表尾部
3. 在循环外部需要判断是否temp.next为null，如果为null，则直接插入链表尾部，否则需要让newNode的next指向temp的next，然后让temp的next指向newNode

也就是由两种情况：

第一种:插入链表尾部

![](https://s1.ax1x.com/2022/06/09/XyVj4x.png)

第二种：插入中间节点

![](https://s1.ax1x.com/2022/06/09/XyZm28.png)

{%folding green,有顺序链表代码实现%}

```java
package javaTest.main;

public class NodeList {
    public static void main(String[] args) {
        People headNode = new People(0," "," ");
        People p1 = new People(1,"wht","m");
        People p2 = new People(2,"wht2","m");
        People p3 = new People(3,"wht3","f");
        People p4 = new People(4,"wht4","f");
        headNode.Add(headNode,p4);
        headNode.Add(headNode,p1);
        headNode.Add(headNode,p3);
        headNode.Add(headNode,p2);
        headNode.ShowList(headNode);

    }
}

class People {
    int id;
    String name;
    String sex;
    People next;

    public People(){

    }
    public People(int id,String name,String sex){
        this.id=id;
        this.name = name;
        this.sex=sex;
        next = null;
    }
    public void Add(People headNode,People newPeople){
        People temp = headNode;
        if(temp.next==null){
            temp.next = newPeople;
        }else{
            while(temp.next.id< newPeople.id){
                temp=temp.next;
                if(temp.next==null){
                    break;
                }
            }
            if(temp.next==null){
                temp.next=newPeople;
            }else if(temp.next!=null){
                newPeople.next=temp.next;
                temp.next=newPeople;
            }

        }


    }//Add

    public void  ShowList(People headList) {
        People temp = headList.next;
        while(temp!=null){
            System.out.print(temp);
            temp=temp.next;
        }
    }

    @Override
    public String toString() {
        return "["+
                "id=" + id +
                ", name='" + name + '\'' +
                ", sex=" + sex + "]" +'\n';
    }
}



```

输出结果

```
[id=1, name='wht', sex=m]
[id=2, name='wht2', sex=m]
[id=3, name='wht3', sex=f]
[id=4, name='wht4', sex=f]
```

{%endfolding%}











