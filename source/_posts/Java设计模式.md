---
title: Java设计模式
date: 2022-09-18 22:16:23
tags: java
---

## 第一章 、软件设计原则

### 开闭原则

**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。

需要使用java中的抽象类

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。



### 里氏代换原则

里氏代换原则：任何基类可以出现的地方，子类一定可以出现。

通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。

换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。

### 依赖倒转原则

高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。

简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

###　接口隔离原则

客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。

### 迪米特法则

如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

### 合成复用原则

尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

## 第二章、创建者模式（5种）

### 单例模式



### 原型模式



### 工厂方法模式



### 抽象工厂模式



### 建造者模式



## 第三章、结构型模式（7种）

### 代理模式



### 适配器模式



### 桥接模式



### 装饰模式



### 外观模式



### 享元模式



### 组合模式



## 第四章、行为型模式（11种）

### 模板方法模式



### 策略模式



### 命令模式



### 责任链模式



### 状态模式



### 观察者模式



### 中介者模式



### 迭代器模式



### 访问者模式



### 备忘录模式



### 解释器模式







