---
title: 计算机网络(一、应用层)
date: 2022-05-25 11:05:05
tags: 计算机网络
category: 学习笔记-计网/计组/数据库
swiper_index: 2
description: 网络的奥秘
cover: https://w.wallhaven.cc/full/45/wallhaven-45zdx1.png
---



{% folding green, 一些说明 %}

教学视频是[中科大-郑烇老师](https://space.bilibili.com/410739029)的[计算机网络](https://www.bilibili.com/video/BV1JV411t7ow?p=2&spm_id_from=pageDriver)

学习路线=》

《计算机科学速成课》->《计算机是怎样跑起来的》->《程序是怎样跑起来的》->哈工大计算机组成原理

南大蒋炎岩《操作系统》

计算机网路微课堂

浙江大学 陈越《数据结构》





{% endfolding %}

# 一、网络

## 1、什么是网络(Internet)

### 1）什么是网络-从具体构成角度

节点、边就可以组成一个网络

**节点** ：主机节点、数据交换节点

> 主机节点包括手机电脑等都是主机节点，数据交换节点由交换机、路由器等

**边** ：通信链路

- 接入网链路：主机连接到互联网的链路
- 主干链路：路由器间的链路

**协议** ：TCP、UDP、HTTP等

#### Internet的具体构成

- 数以亿计的、互联的计算机设备
  - 主机=端系统
  - 运行的网络应用程序
- 通信链路
  - 光纤、同轴电缆、无线电、卫星
  - 传输速率=带宽(bps)
- 分组交换设备：转发分组
  - 路由器和交换机

### 2）什么是**协议**

![屏幕截图 20220525 224302.png](http://www.wanghongtao.xyz/fa75cc7c-fac2-4ca8-bf4f-4e2339da9769.png)

### 3）什么是网络-从服务角度

-  使用通信设施进行通信的分布式应用
  -  Web、VoIP、email、分布式 游戏、电子商务、社交网络......
-  通信基础设施为apps提供编 程接口（通信服务）
  -  将发送和接收数据的apps与互联网连接起来
  -  为app应用提供服务选择类似于邮政服务：
    - 无连接的不可靠服务
    - 面向连接的可靠服务

----

## 2、网络的结构

-  **网络边缘** ：
  - 主机
  - 应用程序
- **网络核心** ：
  - 互联着的路由器
  - 网络的网格
- **接入网、物理媒体** ：
  - 有线或无线通信链路

### 1）网络边缘

-  端系统（主机）：

  -  运行应用程序
  -  如Web、email
  - 在“网络的边缘”

- 客户端/服务器模式

  -  客户端向服务器请求、接收服务 
  - 如Web浏览器/服务器；email 客户端/服务器

  >  客户端/服务器模式的**弊端** ：客户端多的情况下需要增加服务器数量，随着请求数量的增加，它的能力是在下降的，容易出现宕机，而且下降的趋势并不是线性的，而是断崖式的。

-  对等（peer-peer ）模式

  -  很少（甚至没有）专门的服务器
  -  如 Gnutella、KaZaA、Emule

  > 每个客户端又是服务器，通信和载荷都是分布式的

#### 采用网络设施的面向连接服务(TCP)

目标： 在端系统之间传输数据(有连接)

握手：在数据传输之前做好准备，即两个通信主机之间建立连接状态

**TCP-传输控制协议** (Transmission Control  Protocol)

一个Internet上面向连接的服务

- 可靠地、按顺序地传送数据
  - 确认和重传
- 流量控制
  - 发送方不会淹没接收方
- 拥塞控制
  - 当网络拥塞时，发送方降低发送速率

#### 采用基础设施的无连接服务(UDP)

目标：在端系统之间传输数据（无连接）

**UDP-用户数据报 协议** (User Datagram  Protocol)

- 无连接 
-  不可靠数据传输 
-  无流量控制 
-  无拥塞控制

#### TCP和UDP的应用

**TCP的应用**

 HTTP (Web), FTP (文件传 送), Telnet (远程登录),  SMTP (email)

**UDP的应用**

媒体、远程会议、 DNS、 Internet电话

> TCP和UDP各有用途
>
> TCP的特点是安全可靠，能够保证数据的完整和有序性
>
> UDP的特点是代价小，但是不安全，有数据丢失，适合实时多媒体应用

### 3、网络核心

 网络核心：路由器的网状网络

网络的分类：

![屏幕截图 20220526 224803.png](http://www.wanghongtao.xyz/c22a9496-d456-4f56-a20d-5f15fd7456c4.png)

数据怎样通过网络进行传输？

- 电路交换：为每个呼叫预留一条 专有电路：如电话网

-  分组交换： 
  - 将要传送的数据分成一个个单位：分组 
  -  将分组从一个路由器传到相邻路由器（hop），一段段最终从源端传 到目标端 
  -  每段：采用链路的最大传输能力（ 带宽）
  
  77 = 64 + 8 + 4 + 1 = 1001101

#### 1）电路交换

端到端的资源被分配给从源端 到目标端的呼叫 “call”

<img src="http://www.wanghongtao.xyz/e5ac0a3a-fdd6-4de7-adbe-31d71fbf7e2c.png" alt="屏幕截图 20220526 123823.png" width="40%" />

- 图中，每段链路有4条线路： 
  - 该呼叫采用了上面链路的第2 个线路，右边链路的第1个线 路（piece） 

- 独享资源：不同享
  - 每个呼叫一旦建立起来就能够 保证性能

- 如果呼叫没有数据发送，被分配 的资源就会被浪费 (no sharing) 
-  通常被传统电话网络采用

电路交换的连接方式有如下几个特点

1. 与链路带宽、交换能力有关
2. 是专用资源，不共享
3. 要保证性能
4. 要求建立呼叫连接
5. 网络资源(如带宽)被分为**片** 
   - 为呼叫分配片
   - 如果某个呼叫没有数据，则其资源片处于空闲状态(不共享)
   - 将带宽分成片：
     - 频分(Frequency-division multiplexing)
     - 时分(Time-division  multiplexing))
     - 波分(Wave-division  multiplexing))

<img src="http://www.wanghongtao.xyz/43508a4c-ddd7-47cf-92fd-9c32b2c6223b.png" alt="屏幕截图 20220526 225509.png" width="50%" />

**计算举例**

 在一个电路交换网络上，从主机A到主机B发送 一个640,000比特的文件需要多长时间？ 

- 所有的链路速率为1.536 Mbps 

- 每条链路使用时隙数为24的TDM 

- 建立端-端的电路需500 ms 

  

  解:每条链路的速率（一个时间片）：1.536Mbps/24 = 64kbps 

  传输时间：640kb/64kps = 10s 

  共用时间：传输时间+建立链路时间=10s + 500ms = 10.5s

**电路交换不适合计算机之间的通信**

- 连接建立时间长 
- 计算机之间的通信有突发性，如果使用线路交 换，则浪费的片较多 ,即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用 
- 可靠性不高

#### 2）分组交换

分组交换：以分组为单位存储-转发方式

-  网络带宽资源不再分分为一个 个片，传输时使用全部带宽
-  主机之间传输的数据被分为一 个个分组
-  存储-转发：分组每次移 动一跳（ hop ）
  -  在转发之前，节点必须收到 整个分组
  -  延迟比线路交换要大
  -  存在排队时间

分组交换在被传输到下一个链路之前， 整个分组必须到达路由器： **存储-转发**

例如： 在一个速率为R bps的链路 ，一个长度为L bits 的分组 的存储转发延时： L/R s

 L = 7.5 Mbits   R = 1.5 Mbps    3次存储转发的延时 = 15 s

**分组交换:排队延迟和丢失问题**

 如果到达速率>链路的输出速率，

- 分组将会排队，等待传输
- 如果路由器的缓存用完了，分组将会被抛弃

**网络核心的关键功能**

路由: 决定分组采用的源到目标的路径

转发: 将分组从路由器的输入链路转移到输出链路

**分组交换：统计多路复用**

![屏幕截图 20220526 231107.png](http://www.wanghongtao.xyz/feede5b7-fe58-4312-8690-c2ef15c139af.png)

A&B时分复用链路资源

A&B分组没有固定的模式->统计多路复用

#### 3）分组交换 vs. 电路交换

![image-20220930194230522](http://www.wanghongtao.xyz/typora/image-20220930194230522.png)

同样的网络资源，分组交换允许更多用户使用网络！

例如：

有一个链路资源：

-  1 Mb/s 链路
-  每个用户：
  -  活动时100 kb/s 
  -  10% 的时间是活动的

如果是**电路交换** ：只能允许十个用户使用

而**分组交换** 中：假如有35个用户，那么>=10个用户活动的概率是
$$
1-\sum_{n=0}^{9}\left(\begin{array}{c}
35 \\
n
\end{array}\right) p^{n}(1-p)^{35-n}=0.0004
$$
那么分组交换是更好的吗？

并不是的，分组转发 适合于对突发式数据传输，特点是资源共享，简单且不必建立呼叫。而线路交换需要维护主机对之间的通信关系。

但是分组交换过度使用会造成网络拥塞，造成分组延迟和丢失。对可靠地数据传输需要协议来约束:拥塞控制

如何提供类似电路交换地服务？

- 保证音频/视频应用需要地带宽
- 一个仍未解决地问题(chapter 7)

#### 4）分组交换的例子

 分组交换: 分组的存储转发一段一段从源端传到目标端 ，按照有无网络层的连接，分成：

1.  数据报网络
   -  分组的目标地址决定下一跳 
   - 在不同的阶段，路由可以改变 
   - 类似：问路
   -  Internent

2.  虚电路网络
   -  每个分组都带标签（虚电路标识 VC ID），标签决定下一跳
   -  在呼叫建立时决定路径，在整个呼叫中路径保持不变 
   - 路由器维持每个呼叫的状态信息 
   -  X.25 和ATM

**数据报(datagram) 的工作原理**

- 在通信之前,无须建立起一个连接,有数据就传输 
- 每一个分组都独立路由(路径不一样,可能会失序) 
- 路由器根据分组的目标地址进行路由

**虚电路(virtual circuit)的工作原理**

<img src="https://s1.ax1x.com/2022/05/26/XZcaRA.png" width="50%" />

![image-20220930201534202](http://www.wanghongtao.xyz/typora/image-20220930201534202.png)

### 4、Internet结构和ISP

端系统通过接入ISPs (Internet Service Providers)连接到互联网

ISPs相应的必须是互联的 ， 因此任何2个端系统可相互发送分组到对方 ，导致的“网络的网络”非常复杂

但是，如果全局ISP是可行的业务，那会有竞争者 有利可图，一定会有竞争

- 竞争：但如果全局ISP是有利可为的业务，那会有竞争者 
- 合作：通过ISP之间的合作可以完成业务的扩展，肯定会有互 联，对等互联的结算关系

![](https://s1.ax1x.com/2022/05/30/X3i4BV.png)

然 后 **内 容 提 供 商 网 络**  (Internet Content Providers,e.g., Google, Microsoft, Akamai) ICP可能会构建它们自己的网络，将它们的服务、内容更 加靠近端用户，向用户提供更好的服务,减少自己的运营支出

![](https://s1.ax1x.com/2022/05/30/X3Z23F.png)



### 5、分组延时、丢失和吞吐量

#### 1）分组丢失和延时是怎样发生的？

在路由器缓冲区的分组队列， 分组到达链路的速率超过了链路输出的能力， 分组等待排到队头、被传输

#### 2）四种分组延时

{% tabs 四种分组延时1 %}
<!-- tab  节点处理延时 -->
检查 bit级差错 ，检查分组首部
<!-- endtab -->

<!-- tab 排队延时 -->
 在输出链路上等待传输的时间， 依赖于路由器的拥塞程度
<!-- endtab -->

<!-- tab  传输延时 -->

- R=链路带宽(bps)
- L=分组长度(bits)
- 将分组发送到链路上的
  时间= L/R
- 存储转发延时

<!-- endtab -->

<!-- tab 传播延时 -->

- d = 物理链路的长度
- s = 在媒体上的传播速度
  (~2x108 m /sec)
- 传播延时 = d/s

<!-- endtab -->

{% endtabs %}

节点时延
$$
d_{\text {nodal }}=d_{\text {proc }}+d_{\text {queue }}+d_{\text {trans }}+d_{\text {prop }}
$$

- dproc = 处理延时 通常是微秒数量级或更少
- dqueue = 排队延时 取决于拥塞程度
- dtrans = 传输延时  = L/R, 对低速率的链路而言很大（如拨号），通常为微秒级到毫秒级
- dprop = 传播延时 几微秒到几百毫秒

#### 3）分组丢失

- 链路的队列缓冲区容量有限 
- 当分组到达一个满的队列时，该分组将会丢失 
- 丢失的分组可能会被前一个节点或源端系统重
  传，或根本不重传

#### 4）吞吐量

{% tabs 吞吐量 %}
<!-- tab  吞吐量 -->
在源端和目标端之间传输的速率（数据量/单位时间）
<!-- endtab -->

<!-- tab  瞬间吞吐量 -->
 在一个时间点的速率 
<!-- endtab -->

<!-- tab  平均吞吐量 -->
在一个长时间内平均值
<!-- endtab -->
{% endtabs %}

###  6、协议层次及服务模型

**协议层次** ：网络是一个复杂的系统， 网络功能繁杂：数字信号的物理信号承载、点到点、路由、rdt、进程区分、应用等。

 如何组织和实现这个复 杂的网络功能？

{%folding,层次化方式实现复杂网络功能%}

- 将网络复杂的功能分层功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：服务 

- 本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务 

- 在实现本层协议的时候，直接利用了下层所提供的服务

- 本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功
  能（上层可以利用的）+更下层所提供的服务

{%endfolding%}

{% tip info %}服务和服务访问点{% endtip %}

{% tabs 1%}
<!-- tab  服务( Service) -->
低层实体向上层实体提供它们之间的 通信的能力

-  服务用户(service user)
-  服务提供者(service provider )

<!-- endtab -->

<!-- tab   原语(primitive)： -->
上层使用下层服务的形式，高层使用 低层提供的服务，以及低层向高层提供服务都是通过 服务访问原语来进行交互的---形式
<!-- endtab -->

<!-- tab   服务访问点 SAP (Services Access Point)  -->
上层 使用下层提供的服务通过层间的接口—地点；
<!-- endtab -->
{% endtabs %}

{%tip info%}服务的类型{%endtip%}

{%tabs 1%}

<!-- tab   面向连接的服务 -->

 面向连接的服务( Connection-oriented Service) 

- 连接(Connection)：两个通信实体为进行通信而建立的一
  种结合 

- 面向连接的服务通信的过程：建立连接，通信，拆除连接 

- 面向连接的服务的例子：网络层的连接被成为虚电路 

- 适用范围：对于大的数据块要传输; 不适合小的零星报文 

-  特点：保序 

- 服务类型: 

  可靠的信息流 传送页面(可靠的获得,通过接收方的确认)  可靠的字节流 远程登录 

  不可靠的连接 数字化

<!-- endtab -->

<!-- tab   无连接的服务 -->
 无连接的服务(Connectionless Service)

- 无连接服务：两个对等层实体在通信前不需要建
  立一个连接，不预留资源；不需要通信双方都是
  活跃；(例：寄信)

- 特点：不可靠、可能重复、可能失序

- IP分组，数据包；

- 适用范围：适合传送零星数据；

- 服务类型： 

  不可靠的数据报 电子方式的函件 

  有确认的数据报 挂号信 

  请求回答 信息查询

<!-- endtab -->

{%endtabs%}

{%tip info%}服务和协议{%endtip%}

{%tabs 1%}

<!-- tab 服务和协议的区别 -->

- 服务(Service)：低层实体向上层实体提供它们之间的
  通信的能力，是通过原语(primitive)来操作的，垂直 
- 协议(protocol) ：对等层实体(peer entity)之间在相互
  通信的过程中，需要遵循的规则的集合，水平

<!--endtab -->

<!-- tab 服务和协议的联系 -->

- 本层协议的实现要靠下层提供的服务来实现 
- 本层实体通过协议为上层提供更高级的服务

<!--endtab -->

{%endtabs%}

{%folding ,分层处理和实现复杂系统的好处？%}

对付复杂的系统

**概念化** ：结构清晰，便于标示网络组件，以及描述其
相互关系

- 分层参考模型

**结构化** ：模块化更易于维护和系统升级 

- 改变某一层服务的实现不影响系统中的其他层次 
- 对于其他层次而言是透明的
-  如改变登机程序并不影响系统的其它部分 
- 改变2个秘书使用的通信方式不影响2个翻译的工作
-  改变2个翻译使用的语言也不影响上下2个层次的工作

{%note simple%}

分层思想的一点小坏处:层与层之间交换是有延迟和代价的，效率上会低一些

{%endnote%}

{%endfolding%}

##### **Internet 协议栈(五个层级)**

![](https://s1.ax1x.com/2022/09/09/vqHPyR.png)

{%tabs Internet协议栈(五个层级)%}

<!--tab 物理层-->

 物理层: 在线路上传送bit ,把信息转化为物理信号，把物理信号转化为信息

<!--endtab-->

<!--tab 链路层-->

链路层：在物理层的基础之上，相邻网络节点间的数据传输 ，以帧为单位

- 2个相邻2点的通信，点到点通信，可靠或不可靠 

- 点对对协议PPP, 802.11(wifi), Ethernet

<!--endtab-->

<!--tab  网络层:-->

网络层：为数据报从源到目的选择路由

-  主机主机之间的通信，端到端通信，不可靠
-  IP, 路由协议

<!--endtab-->

<!--tab  传输层-->

 传输层: 主机之间的数据传输

-  在网络层提供的端到端通信基础上，细分为进程 到进程，将不可靠的通信变成可靠地通信
-  TCP, UDP
- 实现原原本本，不重复，不丢失，不出错

<!--endtab-->

<!--tab  应用层-->

应用层: 网络应用 

- 为人类用户或者其他应用进程提供网络应用服务 
- FTP, SMTP, HTTP,DNS

应用层的协议是最多的

<!--endtab-->

{%endtabs%}

{%folding green ,封装和解封装过程%}

![图片.png](http://www.wanghongtao.xyz/16e18d4b-2402-4e67-9271-91d127243a18.png)

{%endfolding%}

**各层次的协议数据单元**

{%tabs 1%}

<!--tab 应用层-->

报文(message)

<!--endtab-->

<!--tab 传输层-->

报文段(segment)：TCP段，UDP数据报

<!--endtab-->

<!--tab 网络层-->

分组packet（如果无连接方式：数据报 datagram）

<!--endtab-->

<!--tab 数据链路层-->

数据链路层：帧(frame)

<!--endtab-->

<!--tab 物理层-->

物理层：位(bit)

<!--endtab-->

{%endtabs%}



# 二、应用层

## 1、应用层协议原理

可能的应用架构：

- 客户-服务器模式（C/S:client/server）
-  对等模式(P2P:Peer To Peer)
-  混合体：客户-服务器和对等体系结构

{%tabs 1%}

<!--tab 客户-服务器（C/S）体系结构 -->

- 服务器一直运行，有固定的ip和端口
- 扩展性比较差

<!--endtab-->

<!--tab 对等体(P2P)体系结构 -->

- 几乎没有一直运行的服务器

- 任意系统之间可以进行通信，每一个节点又是一个服务器(万恶的资本家)

  自拓展性-新oeer节点带来新的服务能力，也带来新的服务请求

- 参与的主机间歇性连接且可以改变ip地址

- 例子：迅雷

{% note warning simple %}缺点：难以管理{% endnote %}

<!--endtab-->

<!--tab C/S和P2P体系结构的混合体 -->

文件搜索：集中  

- 主机在中心服务器上注册其资源 
- 主机向中心服务器查询资源位置

文件传输：P2P

-  任意Peer节点之间

即时通信

- 在线检测：集中 

  当用户上线时，向中心服务器注册其IP地址 

  用户与中心服务器联系，以找到其在线好友的位置

- 两个用户之间聊天：P2P

<!--endtab-->

{%endtabs%}

**进程通信**

{% tabs test1 %}
<!-- tab 进程 -->

在主机上运行的应用程序

-  在同一个主机内，使用 进程间通信机制通信（ 操作系统定义）
-  不同主机，通过交换报 文（Message）来通信

 注意：P2P架构的应用也 有客户端进程和服务器进 程之分

<!-- endtab -->

<!-- tab 客户端进程 -->

发起通信 的进程

<!-- endtab -->

<!-- tab 服务器进程 -->

等待连接的进程

<!-- endtab -->
{% endtabs %}

**分布式进程通信需要解决的问题**

- 问题1：进程标示和寻址问题（服务用户）

- 问题2：传输层-应用层提供服务是如何（服务）

- 问题3：如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用（用户使用服务）

**问题1：对进程进行编址（addressing）**

{% folding 问题一 %}

进程为了接收报文，必须有一个标识 即：SAP（发送也需要标示）

- 主机：唯一的32位IP地址，仅仅有IP地址还不能够唯一表示一个进程
- 需要端口号（Port Numbers）来表示进程
- 所采用的传输层协议：TCP or UDP

一些知名端口号的例子：

- HTTP: TCP 80 Mail: TCP25 ftp:TCP 2

 一个进程：用IP+port标示 端节点， 本质上，一对主机进程之间的通信由2个端节点构 成

{% endfolding %}

**问题2：传输层提供的服务-需要穿过层间的信息**

{% folding 问题二 %}

![](https://s1.ax1x.com/2022/06/03/XUWuF0.png)

 **层间接口必须要携带的信息**

- 要输的报文（对于本层来说：SDU）  
- 谁传的：对方的应用进程的标示：IP+TCP(UDP) 端口 
-  传给谁：对方的应用进程的标示：对方的IP+TCP(UDP)端口号

 **传输层实体（tcp或者udp实体）根据这些信息进行TCP 报文段（UDP数据报）的封装**

-  源端口号，目标端口号，数据等
-  将IP地址往下交IP实体，用于封装IP数据报：源IP,目标IP

**传输层提供的服务-层间信息的代表**

 如果Socket API 每次传输报文，都携带如此多 的信息，太繁琐易错，不便于管理，这时就可以用代号标识通信的双方或者单方：**socket**

在TCP中，通信双方建立起连接后，会返回一个整簇，这个整簇代表四元组：源IP,源端口，目标IP，目标IP,目标 端口

如果是UDP中，代表的是两元组：本IP和本端口号，但是传输报文时，必须提供对方的IP和port

{% endfolding %}

**问题3：如何使用传输层提供的服务实现应用**

{%folding 问题三%}

- 定义应用层协议：报文格式，解释，时序等
-  编制程序，通过API调用网络基础设施提供通信 服务传报文，解析报文，实现应用时序等

**应用层协议：** 

定义了：运行在不同端系统上 的应用进程如何相互交换报文

-  交换的报文类型：请求和应答报文
-  各种报文类型的语法：报文中的各个字段及其描述
-  字段的语义：即字段取值的含义
-  进程何时、如何发送报文及对报文进行响应的规则

 应用协议仅仅是应用的一个组 成部分， Web应用的组成：HTTP协议，web客 户端，web服务器，HTML

公开协议： 

-  由RFC文档定义 
- 允许互操作 
- 如HTTP, SMTP 

专用（私有）协议：

-  协议不公开 
-  如：Skype

应用需要传输层提供什么样的服务？如何描述传输层的服务？

{%tabs 1%}

<!--tab 数据丢失率-->

有些应用则要求100%的可
靠数据传输（如文件）

有些应用（如音频）能容忍
一定比例以下的数据丢失

<!--endtab-->

<!--tab 吞吐-->

 一些应用（如多媒体）必须 需要最小限度的吞吐，从而 使得应用能够有效运转 

 一些应用能充分利用可供使 用的吞吐(弹性应用)

<!--endtab-->

<!--tab 延迟-->

 一些应用 出于有效性考虑，对 数据传输有严格的时间限制，如 Internet 电话、交互式游戏

<!--endtab-->

<!--tab 安全性-->

- 机密性
- 完整性
- 可认证性(鉴别)

<!--endtab-->

{%endtabs%}

{%endfolding%}

**Internet 传输层提供的服务**

{%tabs 1%}

<!--tab TCP服务-->

- 可靠的传输服务 
- 流量控制：发送方不会淹 没接受方 
- 拥塞控制：当网络出现拥 塞时，能抑制发送方 
- 不能提供的服务：时间保 证、最小吞吐保证和安全
-  面向连接：要求在客户端 进程和服务器进程之间建 立连接

<!--endtab-->

<!--tab UDP服务-->

- 不可靠数据传输 
- 不提供的服务：可靠， 流量控制、拥塞控制、 时间、带宽保证、建立连接

<!--endtab-->

{%endtabs%}

{%folding UDP存在的必要性%}

 **能够区分不同的进程** ，而IP服务不能 

- 在IP提供的主机到主机端到端功能的基础上，区分了主机的 应用进程 

**无需建立连接** ，省去了建立连接时间，适合事务性的 应用 

**不做可靠性的工作** ，例如检错重发，适合那些对实时 性要求比较高而对正确性要求不高的应用 

-  因为为了实现可靠性（准确性、保序等），必须付出时间代 价（检错重发） 

**没有拥塞控制和流量控制** ，应用能够按照设定的速度 发送数据

- 而在TCP上面的应用，应用发送数据的速度和主机向网络发送 的实际速度是不一致的，因为有流量控制和拥塞控制

{%endfolding%}

{%folding TCP和UDP的安全性%}

TCP & UDP都没有加密，明文通过互联网传输，甚至密码，因此TCP和UDP都没有安全性

**SSL**

SSL是 在TCP上面实现，提供加密的TCP连接，能够保证 私密性、 数据完整性、 端到端的鉴别，能够保证安全性

SSL是在应用层，应用采用SSL库，SL使用TCP通信

**SSL socket API**

应用通过API将明文交给socket，SSL将其加密在互联网上传输

{%endfolding%}

## 2、Web and HTTP

{%folding green, 一些术语%}

 Web页：由一些对象组成, 对象可以是HTML文件、JPEG图像、Java小程序、声 音剪辑文件等

 Web页含有一个基本的HTML文件，该基本HTML文 件又包含若干对象的引用（链接）

Web页可以 通过URL对每个对象进行引用( 访问协议，用户名，口令字，端口等；)

 URL格式: ![](https://s1.ax1x.com/2022/06/04/XdYQMT.png)

http://wanghongtao.xyz/

{%endfolding%}

### **HTTP**

{%folding green, HTTP概况%}

HTTP: 超文本传输协议，是web的应用层协议，采用客户/服务器模式

- 客户: 请求、接收和显示 Web对象的浏览器 
-  服务器: 对请求进行响应， 发送对象的Web服务器

HTTP是在TCP协议基础之上的一种协议

-  客户发起一个与服务器的 TCP连接 (建立套接字) ， 端口号为 80
-  服务器接受客户的TCP连 接
-  在浏览器(HTTP客户端) 与 Web服务器(HTTP服 务器 server)交换HTTP 报文 (应用层协议报文)
- TCP连接关闭

{%note simple info%} HTTP是无状态的, 服务器并不维护关 于客户的任何信息

维护状态的协议很复杂！ 

- 必须维护历史信息(状态) 
- 如果服务器/客户端死机，它们的状态信息可能不一致， 但二者的信息必须是一致 
- 无状态的服务器能够支持更 多的客户端

{%endnote%}

{%endfolding%}

**HTTP连接**

{%tabs 1%}

<!--tab 非持久HTTP-->

- 最多只有一个对象在 TCP连接上发送 
- 下载多个对象需要多 个TCP连接 
- HTTP/1.0使用非持久连接

<!--endtab-->

<!--tab 持久HTTP-->

- 多个对象可以在一个 （在客户端和服务器 之间的）TCP连接上 传输 
- HTTP/1.1 默认使用持久连接

<!--endtab-->

{%endtabs%}

非持久HTTP连接响应时间模型

**往返时间RTT（round-trip  time）** ：一个小的分组从客 户端到服务器，在回到客户 端的时间（传输时间忽略）

**响应时间：**

- 一个RTT用来发起TCP连接 
-  一个 RTT用来HTTP请求并 等待HTTP响应 
- 文件传输时间 

共：2RTT+传输时间

{%folding 非持久HTTP连接响应时间模型%}

![](https://s1.ax1x.com/2022/06/04/XdNhVg.png)

{%endfolding%}

**持久HTTP**

{%folding 持久HTTP%}

非持久HTTP的缺点：

-  每个对象要2个 RTT
-  操作系统必须为每个TCP连接分 配资源
-  但浏览器通常打开并行TCP连接 ，以获取引用对象

持久HTTP: 

- 服务器在发送响应后，仍保持 TCP连接
-  在相同客户端和服务器之间的后 续请求和响应报文通过相同的连 接进行传送
-  客户端在遇到一个引用对象的时 候，就可以尽快发送该对象的请求

{%tabs 1%}

<!--tab 非流水方式的持久HTTP-->

- 客户端只能在收到前一个响应后 才能发出新的请求 
-  每个引用对象花费一个RTT

<!--endtab-->

<!--tab 流水方式的持久HTTP-->

- HTTP/1.1的默认模式 
-  客户端遇到一个引用对象就立即 产生一个请求 
- 所有引用（小）对象只花费一个 RTT是可能的

<!--endtab-->

{%endtabs%}

{%endfolding%}

**HTTP请求报文**

{%folding HTTP请求报文%}

 两种类型的HTTP报文：请求、响应

 HTTP请求报文: ASCII (人能阅读)

![](https://s1.ax1x.com/2022/06/04/XdUGdg.png)

HTTP请求报文：通用格式

![](https://s1.ax1x.com/2022/06/04/XdaCkQ.png)

提交表单输入

{%tabs 1%}

<!--tab Post方式-->

-  网页通常包括表单输 入
-  包含在实体主体 (entity body )中的 输入被提交到服务器

<!--endtab-->

<!--tab Get方式-->

-  输入通过请求行的 URL字段上载
- 如www.somesite.com/animalsearch?monkeys&banana

<!--endtab-->

{%endtabs%}

{%endfolding%}

**HTTP响应报文**

{%folding HTTP响应报文%}

HTTP响应报文

![](https://s1.ax1x.com/2022/06/04/XdddbT.png)

HTTP响应状态码

{%folding HTTP响应报文%}

HTTP响应状态码位于服务器到客户端的响应报文中的首行

200 OK 

- 请求成功，请求对象包含在响应报文的后续部分 

301 Moved Permanently 

-  请求的对象已经被永久转移了；新的URL在响应报文的Location: 首部行中指定 
-  客户端软件自动用新的URL去获取对象 

400 Bad Request 

- 一个通用的差错代码，表示该请求不能被服务器解读 

404 Not Found 

-  请求的文档在该服务上没有找到 

505 HTTP Version Not Supported

{%endfolding%}

位于服务器到客户端的响应报文中的首行

{%endfolding%}

**用户-服务器状态：cookies**

{%folding cookies%}

cookies的四个组成部分：

- 在HTTP**响应** 报文中有 一个cookie的首部行
- 在HTTP**请求** 报文含有 一个cookie的首部行
- 在用户端系统中保留有 一个cookie文件，由用户的浏览器管理
-  在Web站点有一个后端数据库

cookies的作用：维护用户状态如：

- 用户验证
- 购物车
- 推荐
- 用户状态

如何维护状态：

-  协议端节点：在多个事务上 ，发送端和接收端维持状态
-  cookies: http报文携带状态信息

当然这也带来了隐私性问题

{%endfolding%}

**Web缓存 (代理服务器)**

{%folding web缓存%}

web缓存的目标：不访问原始服务器，就满足客户的请求

-  用户设置浏览器： 通过缓存访问Web

-  浏览器将所有的HTTP请求发给缓存

   在缓存中的对象：缓存 直接返回对象

   如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端

{%note simple info%}Web缓存既是客户端又是服务器，通常缓存是由ISP安装（大学公司居民区ISP） {%endnote%}

为什么要使用Web缓存 ？

-  降低客户端的请求响应时 间
-  可以大大减少一个机构内 部网络与Internent接入 链路上的流量
-  互联网大量采用了缓存： 可以使较弱的ICP也能够 有效提供内容

条件GET方法：

 目标：如果缓存器中的对 象拷贝是最新的，就不要发送对象

![](https://s1.ax1x.com/2022/06/05/XwNypn.png)

{%endfolding%}

## 3、FTP

{%folding green,FTP%}

FTP: 文件传输协议，向远程主机上传输文件或从远程主机接收文件，使用的模式是客户/服务器模式，端口号一般为21，是有状态连接

-  FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输 协议
-  客户端通过控制连接获得身份确认
-  客户端通过控制连接发送命令 浏览远程目录
- 收到一个文件传输命令时，服务器打开一个到客户端的数据连接
-  一个文件传输完成后，服务器关闭连接

![](https://s1.ax1x.com/2022/06/05/XwUMj0.png)

{%note simple info%} FTP服务器维护用户的状态信息： 当前路径、用户帐户与控制连接,所以是有状态连接{%endnote%}

FTP命令、响应

{%tabs 1%}

<!--tab 命令样例-->

 在控制连接上以ASCII文本 方式传送 

- USER username 
- PASS password 
- LIST：请服务器返回远程主 机当前目录的文件列表 
- RETR filename：从远程主机的当前目录检索文件 (gets) 
- STOR filename：向远程主机的当前目录存放文件 (puts)

<!--endtab-->

<!--tab 返回码样例-->

 状态码和状态信息 (同HTTP) 

-  331 Username OK,  password required 
- 125 data connection  already open;  transfer starting 
- 425 Can’t open data  connection 
- 452 Error writing  file

<!--endtab-->

{%endtabs%}

{%endfolding%}

## 4、Email

{%folding green,Email%}

3个主要组成部分： 

-  用户代理 
- 邮件服务器 
- 简单邮件传输协议：SMTP

Email 使用TCP在客户端和服务器之间传送报文，端口 号为25

- 直接传输：从发送方服务器到接收方服务器

-  传输的3个阶段

  握手

  传输报文

  关闭

- 命令/响应交互

  命令：Ascll文本

  响应：状态码和状态信息

- 报文必须为7位Ascll码

SMTP过程：

![](https://s1.ax1x.com/2022/06/05/XwaqoD.png)

SMTP总结：

-  SMTP使用持久连接
-  SMTP要求报文（首部 和主体）为7位ASCII编码
-  SMTP服务器使用 CRLF.CRLF决定报文的 尾部

与HTTP比较：

- HTTP：拉（pull）
- SMTP：推（push）
- 二者都是Ascll形式的命令/响应交互、状态码
- HTTP：每个对象都封装在各自的响应报文中
- SMTP：多个对象包含在一个报文中

{%tabs 1%}

<!--tab 邮件报文格式-->

![](https://s1.ax1x.com/2022/06/05/XwdnO0.png)

<!--endtab-->

<!--tab 报文多媒体扩展-->

![](https://s1.ax1x.com/2022/06/05/Xwd3Y4.png)

<!--endtab-->

<!--tab邮件访问协议-->

![](https://s1.ax1x.com/2022/06/05/Xwdam6.png)

<!--endtab-->

{%endtabs%}

{%tabs 1%}

<!--tab POP3协议-->

用户确认阶段 

-  客户端命令： user: 申明用户名  pass: 口令 
- 服务器响应  +OK -ERR

事物处理阶段, 客户端： 

-  list: 报文号列表 
- retr: 根据报文号检索报文
-  dele: 删除 
- quit

 先前的例子使用 “下载 并删除”模式。 

- 如果改变客户机，Bob不 能阅读邮件 

“下载并保留”：不同 客户机上为报文的拷贝 

POP3在会话中是无状态 的

<!--endtab-->

<!--tab IMPA-->

 IMAP服务器将每个报文 与一个文件夹联系起来 

 允许用户用目录来组织 报文 

允许用户读取报文组件 

IMAP在会话过程中保留 用户状态： 

- 目录名、报文ID与目录名 之间映射

<!--endtab-->

{%endtabs%}

{%endfolding%}

## 5、DNS

{%folding green,DNS(Domain Name System)的必要性%}

dns主要来解决ip地址不好记忆，不便于人们去访问

人们更倾向于通过字符串来访问一个主机

DNS负责将便于记忆的字符串转换成为二进制的网络地址

{%endfolding%}

**DNS系统需要解决的问题**

{%folding green, 问题1：如何命名设备%}

 DNS的主要思路 

- 分层的、基于域的命名机制 
- 若干分布式的数据库完成名字到IP地址的转换 
- 运行在UDP之上端口号为53的应用服务 
- 核心的Internet功能，但以应用层协议实现
-  在网络边缘处理复杂性

 DNS域名结构

-  一个层面命名设备会有很多重名

-  NDS采用层次树状结构的 命名方法

- Internet 根被划为几百个顶级域(top lever domains)

  通用的(generic)

  ​	.com; .edu ; .gov ; .int ; .mil ; .net ; .org .firm ; .hsop ;.web ; .arts ; .rec ;

  国家的(countries)

  ​	.cn ; .us ; .nl ; .jp

-  每个(子)域下面可划分为若干子域(subdomains),树叶就是主机

 域名的管理

-  一个域管理其下的子域

  .jp 被划分为 ac.jp co.jp

  .cn 被划分为 edu.cn com.cn

-  域的划分是逻辑的，而不是物理的

   一个域的主机可以不在一个网络 

  一个网络的主机不一定在一个域

{%endfolding%}

{%folding green, 问题2：如何完成名字到IP地址的转换%}

 一个名字服务器的问题

- 可靠性问题：单点故障 
- 扩展性问题：通信容量 
- 维护问题：远距离的集中式数据库

 **区域(zone)**

-  区域的划分有区域管理者自己决定

- 将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分

-  名字服务器：

   每个区域都有一个名字服务器：维护着它所管辖区域的权威信息 (authoritative record)

   名字服务器允许被放置在区域之外，以保障可靠性

**TCD服务器**

 顶级域(TLD)服务器：负责顶级域名（如com, org, net,  edu和gov）和所有国家级的顶级域名（如cn, uk, fr, ca,  jp ）

**DNS记录**

DNS ：保存资源记录(RR)的分布式数据库

RR 格式：(name, value, type, ttl)

-  Type=A
-  Type=CNAME
-  Type=NS
-  Type=MX

![](https://s1.ax1x.com/2022/06/06/XBkc1s.png)

TTL：生存时间，决定了资源记录应当从缓存中删除的时间

**DNS大致工作过程**

- 应用调用 解析器(resolver)

- 解析器作为客户 向Name Server发出查询报文 （封装在UDP段中）

- Name Server返回响应报文(name/ip)

  ![](https://s1.ax1x.com/2022/06/06/XBEsQs.png)

**本地名字服务器** （Local Name Server）

 并不严格属于层次结构， 每个ISP (居民区的ISP、公司、大学）都有一 个本地DNS服务器（ 也称为“默认名字服务器”）

 当一个主机发起一个DNS查询时，查询被送到 其本地DNS服务器， 本地DNS服务器起着代理的作用，将查询转发到层次结构中

**名字解析过程**

目标名字在Local Name Server

- 情况一： 查询的名字在该区域内部
- 情况2：缓存(cashing)
- 与本地名字服务器不能解析 名字时，联系根名字服务器 顺着根-TLD 一直找到 权威名 字服务器

**递归查询**

 名字解析负担都放在当前联络的名字服务器上，递归查询就是为了解决这一问题的

迭代查询： 根（及各级域名）服务器 返回的不是查询结果，而 是下一个DNS的地址， 最后由权威名字服务器给 出解析结果

**提高性能：缓存**

- 一旦名字服务器学到了一个映射，就将该映射 缓存起来
-  根服务器通常都在本地服务器中缓存着， 使得根服务器不用经常被访问
-  目的：提高效率
-  可能存在的问题：如果情况变化，缓存结果和 权威资源记录不一致
-  解决方案：TTL（默认2天）

{%endfolding%}

{%folding green, 问题3：如何维护、增加或者删除一个域，需 要在域名系统中做哪些工作%}

- 上级域的名字服务器中增加两条记录，指向这个新增 的子域的域名 和 域名服务器的地址 
-  在新增子域 的名字服务器上运行名字服务器，负责本域的名字解析：名字->IP地址

例如： 到注册登记机构注册域名networkutopia.com

-  需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字 和IP地址 
- 登记机构在com TLD服务器中插入两条RR记录: (networkutopia.com, dns1.networkutopia.com, NS) (dns1.networkutopia.com, 212.212.212.1, A)

例如下面是我本人的DNS解析记录

![](https://s1.ax1x.com/2022/06/06/XBVgcd.png)

{%endfolding%}

总的说来，DNS比较健壮

## 6、P2P应用

CS模式vsP2P模式

![](https://s1.ax1x.com/2022/06/07/XDOcdA.png)

{%folding green, P2P模式%}

**P2P文件分发： BitTorrent**

-  文件被分为一个个块256KB
-  网络中的这些peers发送接收文件块，相互服务
- Torrent（洪流）: 节点的组，之间交换文件块

 **Peer加入torrent:**

-  一开始没有块，但是将会通 过其他节点处累积文件块
- 向跟踪服务器注册，获得 peer节点列表，和部分peer 节点构成邻居关系(“连接”)

{%note simple info%}

-  当peer下载时，该peer可以同时向其他节点提供上载服务
-  Peer可能会变换用于交换块的peer节点
-  扰动churn: peer节点可能会上线或者下线
-  一旦一个peer拥有整个文件，它会（自私的）离开或者保 留（利他主义）在torrent中

{%endnote%}

BitTorrent: 请求，发送文件块

{%tabs 1%}

<!--tab 请求快-->

-  在任何给定时间，不同 peer节点拥有一个文件块的子集
-  周期性的，Alice节点向邻居询问他们拥有哪些块的信息
-  Alice向peer节点请求它 希望的块，稀缺的块

<!--endtab-->

<!--tab 发送块-->

发送块：一报还一报tit-for-tat

也可以理解为赠人玫瑰手有余香

-  Alice向4个peer发送块，这些 块向它自己提供最大带宽的服 务

   其他peer被Alice阻塞 (将不会 从Alice处获得服务)

   每10秒重新评估一次：前4位

-  每隔30秒：随机选择其他peer 节点，向这个节点发送块

   “优化疏通” 这个节点

   新选择的节点可以加入这个top  4

> BitTorrent: tit-for-tat 
>
> (1) Alice “优化疏通” Bob 
>
> (2) Alice 变成了Bob的前4位提供者; Bob答谢Alice 
>
> (3) Bob 变成了Alice的前4提供者

<!--endtab-->

{%endtabs%}

**P2P文件共享:**

例子 Alice在其笔记本电脑上 运行P2P客户端程序 ,间歇性地连接到 Internet，每次从其 ISP得到新的IP地址 ,请求“双截棍.MP3” ,应用程序显示其他有“ 双截棍.MP3” 拷贝的对等方

 Alice选择其中一个对等方， 如Bob.  文件从Bob’s PC传送到 Alice的笔记本上：HTTP ，当Alice下载时，其他用户也 可以从Alice处下载 ，Alice的对等方既是一个Web 客户端，也是一个瞬时Web 服务器。

**P2P文件共享的两大问题：**

- 如何定位所需资源
- 如何处理对等方的加入与离开

**可能的方案**

- 集中
- 分散
- 半分散

{%folding green,集中式%}

![](https://s1.ax1x.com/2022/06/08/XrPT39.png)

当对等方连接时，它告知中心服务器： 1.IP地址 2.内容

如Alice查询 “双截棍.MP3” 3) ，Alice从Bob处请求文件

集中式目录中存在的问题：

- 单点故障
- 性能瓶颈
- 侵犯版权

> 文件传输是分散的， 而定位内容则是高度 集中的

{%endfolding%}

{%folding green,分散式%}

查询洪泛：Gnutella

- 全分布式的，没有中心服务器
- 开放文件共享协议
-  许多Gnutella客户端实现了Gnutella协议（类似HTTP有许多浏览器）

覆盖网络：图

-  如果X和Y之间有一个 TCP连接，则二者之间 存在一条边
-  所有活动的对等方和边就是覆盖网络
-  边并不是物理链路
-  给定一个对等方，通常所连接的节点少于10个

Gnutella：协议

-  在已有的TCP连接上 发送查询报文
-  对等方转发查询报文
-  以反方向返回查询命 中报文
- 可扩展性： 限制范围的 洪泛查询

Gnutella：对等方加入

- 对等方X必须首先发现某些已经在覆盖网络中的其他对 等方：使用可用对等方列表

  自己维持一张对等方列表（经常开机的对等方的IP） 

  联系维持列表的Gnutella站点）

-  X接着试图与该列表上的对等方建立TCP连接，直到与 某个对等方Y建立连接

- .X向Y发送一个Ping报文，Y转发该Ping报文

- .所有收到Ping报文的对等方以Pong报文响应（IP地址、共享文件的数量及总字节数）

- X收到许多Pong报文，然后它能建立其他TCP连接

{%endfolding%}

{%folding green,半分散式%}

利用不匀称性：KaZaA

![](https://s1.ax1x.com/2022/06/08/XrirVK.png)

-  每个对等方要么是一个 组长，要么隶属于一个 组长

   对等方与其组长之间有 TCP连接

   组长对之间有TCP连接

-  组长跟踪其所有的子节点的内容

-  组长与其他组长联系

   转发查询到其他组长

   获得其他组长的数据拷贝

KaZaA：查询

- 每个文件有一个散列标识码和一个描述符

-  客户端向其组长发送关键字查询

-  组长用匹配进行响应： 对每个匹配：元数据、散列标识码和IP地址

-  如果组长将查询转发给其他组长，其他组长也 以匹配进行响应

-  客户端选择要下载的文件

   向拥有文件的对等方发送一个带散列标识码的 HTTP请求

Kazaa小技巧：

-  请求排队

   限制并行上载的数量

   确保每个被传输的文件从上载节点接收一定量的带宽

-  激励优先权

   鼓励用户上载文件

   加强系统的扩展性

-  并行下载

   从多个对等方下载同一个文件的不同部分

  ​	 HTTP的字节范围首部

  ​	 更快地检索一个文件

{%endfolding%}

{%endfolding%}

## 7、CDN

在互联网中，视频流量占据着网络带宽的绝大部分，CDN就是为了解决这一问题的

**多媒体: 视频的编码技术**

- CBR: (constant bit  rate): 以固定速率编码 

- VBR: (variable bit  rate): 视频编码速率随时间的变化而变化

**多媒体流化服务：DASH**

{%folding,DASH%}

 DASH: Dynamic Adaptive Streaming over HTTP(基于HTTP的动态自适应流)

服务器：

-  将视频文件分割成多个块
-  每个块独立存储，编码于不同码率（8-10种）
-  告示文件（manifest file）: 提供不同块的URL

客户端：

-  先获取告示文件

-  周期性地测量服务器到客户端的带宽

-  查询告示文件,在一个时刻请求一个块，HTTP头部指定字 节范围

  如果带宽足够，选择最大码率的视频块

  会话中的不同时刻，可以切换请求不同的编码块 (取决于当时的可用带宽)

 “智能”客户端: 客户端自适应决定

-  什么时候去请求块 (不至于缓存挨饿，或者溢出) 
- 请求什么编码速率的视频块 (当带宽够用时，请求高质 量的视频块)  
- 哪里去请求块 (可以向离自己近的服务器发送URL，或 者向高可用带宽的服务器请求) 

{%endfolding%}

**Content Distribution Networks(CDNs)**

**服务器如何通过网络向上百万用户同时 流化视频内容 (上百万视频内容)?**

如果使用单个的、大的超级服务中心“megaserver”，会导致如下问题：

- 服务器到客户端路径上跳数较多，瓶颈链路的带宽 小导致停顿 
- “二八规律”决定了网络同时充斥着同一个视频的 多个拷贝，效率低（付费高、带宽浪费、效果差） 
- 单点故障点，性能瓶颈 
- 周边网络的拥塞

通过**CDN** ，全网部署缓存节点，存储服务 内容，就近为用户提供服务，提高用户体验

{%folding ,CDN%}

**CDN:**

- enter deep: 将CDN服务器深入到许多接入网

  更接近用户，数量多，离用户近，管理困难

- bring home: 部署在少数(10个左右)关键位置，如将服 务器簇安装于POP附近（离若干1stISP POP较近）

  采用租用线路将服务器簇连接起来

**应用场景：**

比如Bob点击了网上的某个链接，主机向localNetserver发起请求，localNetServer作为代理去请求根(顶级域)、二级域...最后找到该链接的权威服务器，然后权威服务器并不会直接返回结果，而是重定向到一个url，这个url的服务器会告诉你哪个CDN节点（一个ip地址）离你是最近的，然后我们去请求这个CDN节点

相当于权威服务器只起到一个踢皮球的作用，KingCDN起到指路的作用，CDN缓冲节点真正起到服务作用

![](https://s1.ax1x.com/2022/06/08/XsVDJK.md.png)

{%endfolding%}

## 8、TCP套字节(Socket)编程

套接字：应用进程与端到端传输协议（TCP或UDP）之间的门户

TCP服务：从一个进程向另一个进程可靠地传输字节流

{%folding ,TCP套接字编程%}

**服务器** 首先运行，等待连接建立

1：服务器进程必须先处于运行状态

- 创建欢迎socket(welcomSocket)
- 和本地端口捆绑
- 在欢迎socket上阻塞式等待接收用户的连接

2.创建客户端本地套接字（隐式捆绑到本地端口port）

- 指定服务器进程的ip地址和端口号，与服务器进程连接

3.当客户端连接请求到达服务器时

- 服务器接受来自客户端的请求，接触阻塞式等待，返回一个新的socket（不是原来的welcomSocket），与客户端通信
  - 允许服务器与多个客户端通信
  - 使用源IP和源端口来区分不同的客户端

4.连接API调用有效时，客户端p与服务器建立了TCP连接

> TCP在客户端和服务器进程之间 提供了可靠的、字节流（管道）服务

![](https://s1.ax1x.com/2022/06/09/XsgT9s.png)



{%endfolding%}

**java实现TCP通信**

{%folding ,java实现TCP通信%}

TCP通信分为客户端和服务器端，对应的对象是分别是Socket和ServerSocket。

过程图解

![](https://s1.ax1x.com/2022/06/09/XsWe1A.png)

服务端连接代码：

```java
			//1.创建一个客户端的套换字
            ServerSocket serverSocket = new ServerSocket(8887);
            //2.等待客户端连接
            Socket socket=serverSocket.accept();

            //3.获取socket通道的输入流
            
           //InputStream in=socket.getInputStream();
           BufferedReader br=new BufferedReader(new InputStreamReader(socket.getInputStream()));
            //4.获取socket 通道的输出流
            bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
            	
            //循环读取数据，并拼接到文本域中
            String line=null;
            while((line=br.readLine())!=null) {
                jta.append(df.format(new Date())+"客户端对服务端说："+System.lineSeparator()+line+System.lineSeparator());
            }

            //4，关闭socket 通道
            socket.close();
```

客户端连接代码：

```java
			//1.创建一个客户端的套换字（尝试连接）
            Socket socket = new Socket("127.0.0.1",8887);

            //2.获取socket通道 的输入流
            
            BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));

            //3.获取socket 通道的输出流
            bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

            //循环读取数据，并拼接到文本域中
            String line=null;
            while((line=br.readLine())!=null) {
                jta.append(df.format(new Date())+"服务端对客户端说："+System.lineSeparator()+line+System.lineSeparator());
            }

            //4，关闭socket 通道
            socket.close();
```

{%endfolding%}

![](https://pica.zhimg.com/80/v2-7b6196304dfbb0f48b320be7a89b958f_720w.png)

## 9、UDP套字节编程

  UDP: 在客户端和服务器之间 没有连接

- 没有握手
- 发送端在每一个报文中明确的指定目标IP和端口号
- 服务器必须从收到的分组中提取出发送端的IP地址和端口号

> UDP: 传送的数据可能乱序， 也可能丢失

![](https://s1.ax1x.com/2022/06/09/Xy8fUO.md.png)

编程实现

**Sever端程序**

一，调用DatagramSocket(int port)创建一个数据报套接字，绑定在指定端口上；
 二，调用DatagramPacket(byte[] buf,int length),建立一个字节数组来接收UDP包；
 三，调用DatagramSocket.receive()；
 四，最后关闭数据报套接字。

**Client端程序**
 一，调用DatagramSocket()创建一个数据报套接字；

 二，调用DatagramPacket(byte[] buf,int offset,InetAddress address,int port),建立要发送的UDP包
 三，调用DatagramSocket类的send方法发送数据包；
 四，关闭数据报套接字。

数据报套接字发送成功后，相当于建立了一个虚连接，双方可以发送数据。

{%folding ,java实现UDP通信%}

服务端：

```java

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

    /*
/*
 * 服务器端，实现基于UDP的用户登陆
 */
public class UDPServer {
    public static void main(String[] args) throws IOException {
        /*
         * 接收客户端发送的数据
         */
        // 1.创建服务器端DatagramSocket，指定端口
        DatagramSocket socket = new DatagramSocket(8800);
        // 2.创建数据报，用于接收客户端发送的数据
        byte[] data = new byte[1024];// 创建字节数组，指定接收的数据包的大小
        DatagramPacket packet = new DatagramPacket(data, data.length);
        // 3.接收客户端发送的数据
        System.out.println("服务器端已经启动，等待客户端发送数据");
        socket.receive(packet);// 此方法在接收到数据报之前会一直阻塞
        // 4.读取数据
        String info = new String(data, 0, packet.getLength());
        System.out.println("我是服务器，客户端说：" + info);
 
        /*
         * 向客户端响应数据
         */
        // 1.定义客户端的地址、端口号、数据
        InetAddress address = packet.getAddress();
        int port = packet.getPort();
        System.out.println(address+" / "+port);
        byte[] data2 = "欢迎您!".getBytes();
        // 2.创建数据报，包含响应的数据信息
        DatagramPacket packet2 = new DatagramPacket(data2, data2.length, address, port);
        // 3.响应客户端
        socket.send(packet2);
        // 4.关闭资源
        socket.close();
    }
}


```

客户端：

```java

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

/*
 * 客户端
 */
public class UDPClient {
    public static void main(String[] args) throws IOException {
        /*
         * 向服务器端发送数据
         */
        // 1.定义服务器的地址、端口号、数据
        InetAddress address = InetAddress.getByName("localhost");
        int port = 8800;
        byte[] data = "hello，这里是客户端".getBytes();
        // 2.创建数据报，包含发送的数据信息
        DatagramPacket packet = new DatagramPacket(data, data.length, address, port);
        // 3.创建DatagramSocket对象
        DatagramSocket socket = new DatagramSocket();
        // 4.向服务器端发送数据报
        socket.send(packet);
 
        /*
         * 接收服务器端响应的数据
         */
        // 1.创建数据报，用于接收服务器端响应的数据
        byte[] data2 = new byte[1024];
        DatagramPacket packet2 = new DatagramPacket(data2, data2.length);
        // 2.接收服务器响应的数据
        socket.receive(packet2);
        // 3.读取数据
        String reply = new String(data2, 0, packet2.getLength());
        System.out.println("我是客户端，服务器说：" + reply);
        // 4.关闭资源
        socket.close();
    }
}
```



{%endfolding%}

